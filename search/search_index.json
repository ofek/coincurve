{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"coincurve","text":"CI/CD Docs Package Meta <p>This library provides well-tested Python bindings for libsecp256k1, the heavily optimized C library used by Bitcoin Core for operations on the elliptic curve secp256k1.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fastest available implementation (more than 10x faster than OpenSSL)</li> <li>Clean, easy to use API</li> <li>Frequent updates from the development version of libsecp256k1</li> <li>Linux, macOS, and Windows all have binary packages for multiple architectures</li> <li>Deterministic signatures as specified by RFC 6979</li> <li>Non-malleable signatures (lower-S form) by default</li> <li>Secure, non-malleable ECDH implementation</li> </ul>"},{"location":"#users","title":"Users","text":"<ul> <li>Ethereum</li> <li>LBRY</li> <li>libp2p</li> </ul> <p>and many more!</p>"},{"location":"#license","title":"License","text":"<p><code>coincurve</code> is distributed under the terms of any of the following licenses:</p> <ul> <li>MIT</li> <li>Apache-2.0</li> </ul>"},{"location":"#navigation","title":"Navigation","text":"<p>Desktop readers can use keyboard shortcuts to navigate.</p> Keys Action <ul><li>, (comma)</li><li>p</li></ul> Navigate to the \"previous\" page <ul><li>. (period)</li><li>n</li></ul> Navigate to the \"next\" page <ul><li>/</li><li>s</li></ul> Display the search modal"},{"location":"api/","title":"Developer Interface","text":"<p>All objects are available directly under the root namespace <code>coincurve</code>.</p>"},{"location":"api/#coincurve.verify_signature","title":"<code>verify_signature(signature: bytes, message: bytes, public_key: bytes, hasher: Hasher = sha256, context: Context = GLOBAL_CONTEXT) -&gt; bool</code>","text":"<p>Verify an ECDSA signature.</p> <p>Parameters:</p> Name Type Description Default <code>signature</code> <code>bytes</code> <p>The ECDSA signature.</p> required <code>message</code> <code>bytes</code> <p>The message that was supposedly signed.</p> required <code>public_key</code> <code>bytes</code> <p>The formatted public key.</p> required <code>hasher</code> <code>Callable[[bytes], bytes] | None</code> <p>The hash function to use, which must return 32 bytes. By default, the <code>sha256</code> algorithm is used. If <code>None</code>, no hashing occurs.</p> <code>sha256</code> <code>context</code> <code>Context</code> <p>The secp256k1 context.</p> <code>GLOBAL_CONTEXT</code> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating whether or not the signature is correct.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the public key could not be parsed or was invalid, the message hash was not 32 bytes long, or the DER-encoded signature could not be parsed.</p>"},{"location":"api/#coincurve.PrivateKey","title":"<code>PrivateKey</code>","text":""},{"location":"api/#coincurve.PrivateKey.__init__","title":"<code>__init__(secret: bytes | None = None, context: Context = GLOBAL_CONTEXT)</code>","text":"<p>Initializes a private key.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>bytes | None</code> <p>The secret used to initialize the private key.     If not provided, a new key will be generated.</p> <code>None</code> <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code>"},{"location":"api/#coincurve.PrivateKey.sign","title":"<code>sign(message: bytes, hasher: Hasher = sha256, custom_nonce: Nonce = DEFAULT_NONCE) -&gt; bytes</code>","text":"<p>Creates an ECDSA signature.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes</code> <p>The message to sign.</p> required <code>hasher</code> <code>Callable[[bytes], bytes] | None</code> <p>The hash function to use, which must return 32 bytes. By default, the <code>sha256</code> algorithm is used. If <code>None</code>, no hashing occurs.</p> <code>sha256</code> <code>custom_nonce</code> <code>tuple[CData, CData]</code> <p>Custom nonce data in the form <code>(nonce_function, input_data)</code>. For more information, refer to the <code>libsecp256k1</code> documentation here.</p> <code>DEFAULT_NONCE</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The ECDSA signature.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the message hash was not 32 bytes long, the nonce generation         function failed, or the private key was invalid.</p>"},{"location":"api/#coincurve.PrivateKey.sign_recoverable","title":"<code>sign_recoverable(message: bytes, hasher: Hasher = sha256, custom_nonce: Nonce = DEFAULT_NONCE) -&gt; bytes</code>","text":"<p>Creates a recoverable ECDSA signature.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes</code> <p>The message to sign.</p> required <code>hasher</code> <code>Callable[[bytes], bytes] | None</code> <p>The hash function to use, which must return 32 bytes. By default, the <code>sha256</code> algorithm is used. If <code>None</code>, no hashing occurs.</p> <code>sha256</code> <code>custom_nonce</code> <code>tuple[CData, CData]</code> <p>Custom nonce data in the form <code>(nonce_function, input_data)</code>. For more information, refer to the <code>libsecp256k1</code> documentation here.</p> <code>DEFAULT_NONCE</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The recoverable ECDSA signature.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the message hash was not 32 bytes long, the nonce generation function failed, or the private key was invalid.</p>"},{"location":"api/#coincurve.PrivateKey.sign_schnorr","title":"<code>sign_schnorr(message: bytes, aux_randomness: bytes = b'') -&gt; bytes</code>","text":"<p>Creates a Schnorr signature.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes</code> <p>The message to sign.</p> required <code>aux_randomness</code> <code>bytes</code> <p>32 bytes of fresh randomness, empty bytestring (auto-generated), or None (no randomness).</p> <code>b''</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The Schnorr signature.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the message was not 32 bytes long, the optional auxiliary random data was not 32 bytes long, signing failed, or the signature was invalid.</p>"},{"location":"api/#coincurve.PrivateKey.ecdh","title":"<code>ecdh(public_key: bytes) -&gt; bytes</code>","text":"<p>Computes an EC Diffie-Hellman secret in constant time.</p> <p>Note</p> <p>This prevents malleability by returning <code>sha256(compressed_public_key)</code> instead of the <code>x</code> coordinate directly.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The formatted public key.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The 32-byte shared secret.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the public key could not be parsed or was invalid.</p>"},{"location":"api/#coincurve.PrivateKey.add","title":"<code>add(scalar: bytes, update: bool = False) -&gt; PrivateKey</code>","text":"<p>Adds a scalar to the private key.</p> <p>Parameters:</p> Name Type Description Default <code>scalar</code> <code>bytes</code> <p>The scalar with which to add.</p> required <code>update</code> <code>bool</code> <p>Whether to update the private key in-place.</p> <code>False</code> <p>Returns:</p> Type Description <code>PrivateKey</code> <p>The new private key, or the modified private key if <code>update</code> is <code>True</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tweak was out of range or the resulting private key was invalid.</p>"},{"location":"api/#coincurve.PrivateKey.multiply","title":"<code>multiply(scalar: bytes, update: bool = False) -&gt; PrivateKey</code>","text":"<p>Multiplies the private key by a scalar.</p> <p>Parameters:</p> Name Type Description Default <code>scalar</code> <code>bytes</code> <p>The scalar with which to multiply.</p> required <code>update</code> <code>bool</code> <p>Whether to update the private key in-place.</p> <code>False</code> <p>Returns:</p> Type Description <code>PrivateKey</code> <p>The new private key, or the modified private key if <code>update</code> is <code>True</code>.</p>"},{"location":"api/#coincurve.PrivateKey.to_int","title":"<code>to_int() -&gt; int</code>","text":"<p>Returns the private key as an integer.</p>"},{"location":"api/#coincurve.PrivateKey.to_hex","title":"<code>to_hex() -&gt; str</code>","text":"<p>Returns the private key encoded as a hex string.</p>"},{"location":"api/#coincurve.PrivateKey.to_pem","title":"<code>to_pem() -&gt; bytes</code>","text":"<p>Returns the private key encoded in PEM format.</p>"},{"location":"api/#coincurve.PrivateKey.to_der","title":"<code>to_der() -&gt; bytes</code>","text":"<p>Returns the private key encoded in DER format.</p>"},{"location":"api/#coincurve.PrivateKey.from_int","title":"<code>from_int(num: int, context: Context = GLOBAL_CONTEXT) -&gt; PrivateKey</code>  <code>classmethod</code>","text":"<p>Creates a private key from an integer.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>The private key as an integer.</p> required <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code> <p>Returns:</p> Type Description <code>PrivateKey</code> <p>The private key.</p>"},{"location":"api/#coincurve.PrivateKey.from_hex","title":"<code>from_hex(hexed: str, context: Context = GLOBAL_CONTEXT) -&gt; PrivateKey</code>  <code>classmethod</code>","text":"<p>Creates a private key from a hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hexed</code> <code>str</code> <p>The private key encoded as a hex string.</p> required <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code> <p>Returns:</p> Type Description <code>PrivateKey</code> <p>The private key.</p>"},{"location":"api/#coincurve.PrivateKey.from_pem","title":"<code>from_pem(pem: bytes, context: Context = GLOBAL_CONTEXT) -&gt; PrivateKey</code>  <code>classmethod</code>","text":"<p>Creates a private key from PEM format.</p> <p>Parameters:</p> Name Type Description Default <code>pem</code> <code>bytes</code> <p>The private key encoded in PEM format.</p> required <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code> <p>Returns:</p> Type Description <code>PrivateKey</code> <p>The private key.</p>"},{"location":"api/#coincurve.PrivateKey.from_der","title":"<code>from_der(der: bytes, context: Context = GLOBAL_CONTEXT) -&gt; PrivateKey</code>  <code>classmethod</code>","text":"<p>Creates a private key from DER format.</p> <p>Parameters:</p> Name Type Description Default <code>der</code> <code>bytes</code> <p>The private key encoded in DER format.</p> required <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code> <p>Returns:</p> Type Description <code>PrivateKey</code> <p>The private key.</p>"},{"location":"api/#coincurve.PublicKey","title":"<code>PublicKey</code>","text":""},{"location":"api/#coincurve.PublicKey.__init__","title":"<code>__init__(data: bytes | ffi.CData, context: Context = GLOBAL_CONTEXT)</code>","text":"<p>Initializes a public key.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The formatted public key. This class supports parsing compressed (33 bytes, header byte <code>0x02</code> or <code>0x03</code>), uncompressed (65 bytes, header byte <code>0x04</code>), or hybrid (65 bytes, header byte <code>0x06</code> or <code>0x07</code>) format public keys.</p> required <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the public key could not be parsed or was invalid.</p>"},{"location":"api/#coincurve.PublicKey.verify","title":"<code>verify(signature: bytes, message: bytes, hasher: Hasher = sha256) -&gt; bool</code>","text":"<p>Verifies an ECDSA signature.</p> <p>Parameters:</p> Name Type Description Default <code>signature</code> <code>bytes</code> <p>The ECDSA signature.</p> required <code>message</code> <code>bytes</code> <p>The message that was supposedly signed.</p> required <code>hasher</code> <code>Callable[[bytes], bytes] | None</code> <p>The hash function to use, which must return 32 bytes. By default, the <code>sha256</code> algorithm is used. If <code>None</code>, no hashing occurs.</p> <code>sha256</code> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating whether the signature is correct.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the message hash was not 32 bytes long or the DER-encoded signature could not be parsed.</p>"},{"location":"api/#coincurve.PublicKey.format","title":"<code>format(compressed: bool = True) -&gt; bytes</code>","text":"<p>Formats the public key.</p> <p>Parameters:</p> Name Type Description Default <code>compressed</code> <code>bool</code> <p>Whether to use the compressed format.</p> <code>True</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The 33 byte formatted public key, or the 65 byte formatted public key</p> <code>bytes</code> <p>if <code>compressed</code> is <code>False</code>.</p>"},{"location":"api/#coincurve.PublicKey.point","title":"<code>point() -&gt; tuple[int, int]</code>","text":"<p>Returns the public key as a coordinate point.</p>"},{"location":"api/#coincurve.PublicKey.combine","title":"<code>combine(public_keys: list[PublicKey], update: bool = False) -&gt; PublicKey</code>","text":"<p>Adds a number of public keys together.</p> <p>Parameters:</p> Name Type Description Default <code>public_keys</code> <code>list[PublicKey]</code> <p>A sequence of public keys.</p> required <code>update</code> <code>bool</code> <p>Whether to update the public key in-place.</p> <code>False</code> <p>Returns:</p> Type Description <code>PublicKey</code> <p>The combined public key, or the modified public key if <code>update</code> is <code>True</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sum of the public keys was invalid.</p>"},{"location":"api/#coincurve.PublicKey.add","title":"<code>add(scalar: bytes, update: bool = False) -&gt; PublicKey</code>","text":"<p>Adds a scalar to the public key.</p> <p>Parameters:</p> Name Type Description Default <code>scalar</code> <code>bytes</code> <p>The scalar with which to add.</p> required <code>update</code> <code>bool</code> <p>Whether to update the public key in-place.</p> <code>False</code> <p>Returns:</p> Type Description <code>PublicKey</code> <p>The new public key, or the modified public key if <code>update</code> is <code>True</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tweak was out of range or the resulting public key was invalid.</p>"},{"location":"api/#coincurve.PublicKey.multiply","title":"<code>multiply(scalar: bytes, update: bool = False) -&gt; PublicKey</code>","text":"<p>Multiplies the public key by a scalar.</p> <p>Parameters:</p> Name Type Description Default <code>scalar</code> <code>bytes</code> <p>The scalar with which to multiply.</p> required <code>update</code> <code>bool</code> <p>Whether to update the public key in-place.</p> <code>False</code> <p>Returns:</p> Type Description <code>PublicKey</code> <p>The new public key, or the modified public key if <code>update</code> is <code>True</code>.</p>"},{"location":"api/#coincurve.PublicKey.combine_keys","title":"<code>combine_keys(public_keys: list[PublicKey], context: Context = GLOBAL_CONTEXT) -&gt; PublicKey</code>  <code>classmethod</code>","text":"<p>Adds a number of public keys together.</p> <p>Parameters:</p> Name Type Description Default <code>public_keys</code> <code>list[PublicKey]</code> <p>A sequence of public keys.</p> required <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code> <p>Returns:</p> Type Description <code>PublicKey</code> <p>The combined public key.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sum of the public keys was invalid.</p>"},{"location":"api/#coincurve.PublicKey.from_signature_and_message","title":"<code>from_signature_and_message(signature: bytes, message: bytes, hasher: Hasher = sha256, context: Context = GLOBAL_CONTEXT) -&gt; PublicKey</code>  <code>classmethod</code>","text":"<p>Recovers an ECDSA public key from a recoverable signature.</p> <p>Parameters:</p> Name Type Description Default <code>signature</code> <code>bytes</code> <p>The recoverable ECDSA signature.</p> required <code>message</code> <code>bytes</code> <p>The message that was supposedly signed.</p> required <code>hasher</code> <code>Callable[[bytes], bytes] | None</code> <p>The hash function to use, which must return 32 bytes. By default, the <code>sha256</code> algorithm is used. If <code>None</code>, no hashing occurs.</p> <code>sha256</code> <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code> <p>Returns:</p> Type Description <code>PublicKey</code> <p>The public key that signed the message.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the message hash was not 32 bytes long or recovery of the ECDSA public key failed.</p>"},{"location":"api/#coincurve.PublicKey.from_secret","title":"<code>from_secret(secret: bytes, context: Context = GLOBAL_CONTEXT) -&gt; PublicKey</code>  <code>classmethod</code>","text":"<p>Derives a public key from a private key secret.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>bytes</code> <p>The private key secret.</p> required <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code> <p>Returns:</p> Type Description <code>PublicKey</code> <p>The public key.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid secret was used.</p>"},{"location":"api/#coincurve.PublicKey.from_valid_secret","title":"<code>from_valid_secret(secret: bytes, context: Context = GLOBAL_CONTEXT) -&gt; PublicKey</code>  <code>classmethod</code>","text":"<p>Derives a public key from a valid private key secret, avoiding input checks.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>bytes</code> <p>The private key secret.</p> required <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code> <p>Returns:</p> Type Description <code>PublicKey</code> <p>The public key.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the secret was invalid.</p>"},{"location":"api/#coincurve.PublicKey.from_point","title":"<code>from_point(x: int, y: int, context: Context = GLOBAL_CONTEXT) -&gt; PublicKey</code>  <code>classmethod</code>","text":"<p>Derives a public key from a coordinate point.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The x coordinate.</p> required <code>y</code> <code>int</code> <p>The y coordinate.</p> required <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code> <p>Returns:</p> Type Description <code>PublicKey</code> <p>The public key.</p>"},{"location":"api/#coincurve.PublicKeyXOnly","title":"<code>PublicKeyXOnly</code>","text":""},{"location":"api/#coincurve.PublicKeyXOnly.__init__","title":"<code>__init__(data: bytes | ffi.CData, parity: bool = False, context: Context = GLOBAL_CONTEXT)</code>","text":"<p>Initializes a BIP340 <code>x-only</code> public key.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The formatted public key.</p> required <code>parity</code> <code>bool</code> <p>Whether the encoded point is the negation of the public key.</p> <code>False</code> <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the public key could not be parsed or is invalid.</p>"},{"location":"api/#coincurve.PublicKeyXOnly.verify","title":"<code>verify(signature: bytes, message: bytes) -&gt; bool</code>","text":"<p>Verifies a Schnorr signature over a given message.</p> <p>Parameters:</p> Name Type Description Default <code>signature</code> <code>bytes</code> <p>The 64-byte Schnorr signature to verify.</p> required <code>message</code> <code>bytes</code> <p>The message to be verified.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating whether the signature is correct.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signature is not 64 bytes long.</p>"},{"location":"api/#coincurve.PublicKeyXOnly.format","title":"<code>format() -&gt; bytes</code>","text":"<p>Serializes the public key.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The public key serialized as 32 bytes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the public key in <code>self.public_key</code> is invalid.</p>"},{"location":"api/#coincurve.PublicKeyXOnly.tweak_add","title":"<code>tweak_add(scalar: bytes) -&gt; None</code>","text":"<p>Adds a scalar to the public key.</p> <p>Parameters:</p> Name Type Description Default <code>scalar</code> <code>bytes</code> <p>The scalar with which to add.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The modified public key.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tweak was out of range or the resulting public key would be invalid.</p>"},{"location":"api/#coincurve.PublicKeyXOnly.from_secret","title":"<code>from_secret(secret: bytes, context: Context = GLOBAL_CONTEXT) -&gt; PublicKeyXOnly</code>  <code>classmethod</code>","text":"<p>Derives an x-only public key from a private key secret.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>bytes</code> <p>The private key secret.</p> required <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code> <p>Returns:</p> Type Description <code>PublicKeyXOnly</code> <p>The x-only public key.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the secret was invalid.</p>"},{"location":"api/#coincurve.PublicKeyXOnly.from_valid_secret","title":"<code>from_valid_secret(secret: bytes, context: Context = GLOBAL_CONTEXT) -&gt; PublicKeyXOnly</code>  <code>classmethod</code>","text":"<p>Derives an x-only public key from a valid private key secret, avoiding input checks.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>bytes</code> <p>The private key secret.</p> required <code>context</code> <code>Context</code> <p>The context to use.</p> <code>GLOBAL_CONTEXT</code> <p>Returns:</p> Type Description <code>PublicKeyXOnly</code> <p>The x-only public key.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the secret was invalid.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":""},{"location":"benchmarks/#setup","title":"Setup","text":"<p>Download Hatch or UV in order to run the benchmarks as follows:</p> <pre><code>[hatch|uv] run scripts/bench.py\n</code></pre>"},{"location":"benchmarks/#results","title":"Results","text":"Library Key generation Signing Verification Key export Key import coincurve v21.0.0 33.4 52.8 59.0 12.6 39.4 fastecdsa v3.0.1 1319.6 1449.5 1160.4 1402.9 15.5 <p>Note</p> <ul> <li>the timings are in microseconds</li> <li>signing and verification use a 16 KiB message</li> <li>the Python version used for the benchmarks is 3.13.x</li> </ul>"},{"location":"history/","title":"History","text":"<p>Important changes are emphasized.</p>"},{"location":"history/#unreleased","title":"Unreleased","text":""},{"location":"history/#2100","title":"21.0.0","text":"<ul> <li>Breaking: Drop support for Python 3.8</li> <li>Add support for Python 3.13</li> <li>Remove all runtime dependencies (<code>cffi</code> &amp; <code>asn1crypto</code>)</li> <li>Add <code>COINCURVE_VENDOR_CFFI</code> environment variable to control vendoring of the <code>_cffi_backend</code> module</li> <li>Minor performance improvement by removing use of formatted string constants</li> <li>Upgrade libsecp256k1 to version 0.6.0</li> </ul>"},{"location":"history/#2000","title":"20.0.0","text":"<ul> <li>Breaking: CMake is now a build dependency; this is only a breaking change for redistributors as building with standard Python packaging tools will automatically use the CMake that is available on PyPI</li> <li>Breaking: Stop building wheels for Windows 32-bit</li> <li>Build wheels for Windows ARM64</li> <li>Upgrade libsecp256k1 to version 0.5.0</li> </ul>"},{"location":"history/#1901","title":"19.0.1","text":"<ul> <li>Fix regression in Windows wheels</li> </ul>"},{"location":"history/#1900","title":"19.0.0","text":"<ul> <li>Breaking: Drop support for Python 3.7</li> <li>Add support for Python 3.12</li> <li>Upgrade libsecp256k1 to version 0.4.1</li> </ul>"},{"location":"history/#1800","title":"18.0.0","text":"<ul> <li>Support Schnorr signatures</li> <li>Add support for Python 3.11</li> <li>Upgrade libsecp256k1 to the latest available version</li> </ul>"},{"location":"history/#1700","title":"17.0.0","text":"<ul> <li>Breaking: Drop support for Python 3.6</li> <li>Fix wheels for Apple M1</li> <li>Upgrade libsecp256k1 to the latest available version</li> </ul>"},{"location":"history/#1600","title":"16.0.0","text":"<ul> <li>Wheels for Apple Silicon and musl linux (Alpine)</li> <li>No wheels for PyPy until the build system is fixed</li> </ul>"},{"location":"history/#1501","title":"15.0.1","text":"<ul> <li>Fix the <code>combine</code> method of <code>PublicKey</code></li> </ul>"},{"location":"history/#1500","title":"15.0.0","text":"<ul> <li>Breaking: Drop support for Python 2</li> <li>Breaking: Binary wheels for CPython require version 19.3 or later of <code>pip</code> to install</li> <li>Build AArch64 binary wheels for Linux</li> <li>Build binary wheels for PyPy3.6 7.3.3 &amp; PyPy3.7 7.3.3 on Linux</li> <li>Upgrade libsecp256k1 to the latest available version</li> <li>Upgrade libgmp to the latest available version</li> <li>Introduce <code>COINCURVE_UPSTREAM_REF</code> environment variable to select an alternative libsecp256k1 version when building from source</li> <li>Support PEP 561 type hints</li> <li>Added support for supplying a custom nonce to <code>PrivateKey.sign_recoverable</code></li> </ul>"},{"location":"history/#1400","title":"14.0.0","text":"<p>IMPORTANT: This will be the final release that supports Python 2.</p> <ul> <li>New: Binary wheels for Python 3.9</li> <li>Breaking: Drop support for Python 3.5</li> <li>Fetch libsecp256k1 source if the system installation lacks ECDH support</li> <li>Fix innocuous <code>setuptools</code> warning when building from source</li> <li>Switch CI/CD to GitHub Actions</li> </ul>"},{"location":"history/#1300","title":"13.0.0","text":"<ul> <li>New: Binary wheels for Python 3.8</li> <li>Support building on OpenBSD</li> <li>Improve handling of PEM private key deserialization</li> <li>Improve ECDH documentation</li> <li>Improvements from libsecp256k1 master</li> </ul>"},{"location":"history/#1200","title":"12.0.0","text":"<ul> <li>New: Binary wheels on Linux for PyPy3.6 v7.1.1-beta</li> <li>New: Binary wheels on macOS for Python 3.8.0-alpha.3</li> <li>New: Binary wheels on Linux are now also built with the new manylinux2010 spec for 64-bit platforms</li> <li>Improvements from libsecp256k1 master</li> </ul>"},{"location":"history/#1100","title":"11.0.0","text":"<ul> <li>Fix some linking scenarios by placing bundled libsecp256k1 dir first in path</li> <li>Allow override of system libsecp256k1 with environment variable</li> <li>Add benchmarks</li> <li>Use Codecov to track coverage</li> <li>Use black for code formatting</li> </ul>"},{"location":"history/#1000","title":"10.0.0","text":"<ul> <li>Support tox for testing</li> <li>Compatibility with latest libsecp256k1 ECDH API</li> <li>Make libgmp optional when building from source</li> </ul>"},{"location":"history/#900","title":"9.0.0","text":"<ul> <li>Fixed wheels for macOS</li> <li>Breaking: Drop support for 32-bit macOS</li> </ul>"},{"location":"history/#802","title":"8.0.2","text":"<ul> <li>No longer package tests</li> </ul>"},{"location":"history/#800","title":"8.0.0","text":"<ul> <li>New: Binary wheels for Python 3.7</li> <li>Changed: Binary wheels on macOS for Python 3.5 now use Homebrew   Python for compilation due to new security requirements</li> <li>Make build system support new GitHub &amp; PyPI security requirements</li> <li>Improvements from libsecp256k1 master</li> </ul>"},{"location":"history/#710","title":"7.1.0","text":"<ul> <li>Pin version of libsecp256k1</li> <li>Improve docs</li> </ul>"},{"location":"history/#700","title":"7.0.0","text":"<ul> <li>Improvements from libsecp256k1 master</li> <li>Fix build script</li> </ul>"},{"location":"history/#600","title":"6.0.0","text":"<ul> <li>Resolved #6. You can choose to use this or remain on <code>5.2.0</code>. This will only be a temporary change, see 3e93480.</li> </ul>"},{"location":"history/#520","title":"5.2.0","text":"<ul> <li>Added support for supplying a custom nonce to <code>PrivateKey.sign</code></li> </ul>"},{"location":"history/#510","title":"5.1.0","text":"<ul> <li>Added <code>PublicKey.combine_keys</code> class method</li> <li>Improvements to documentation</li> </ul>"},{"location":"history/#501","title":"5.0.1","text":"<ul> <li>Fixed an issue where secret validation would occasionally erroneously error   on user-provided secrets (secrets not generated by Coincurve itself) if there   were not exactly 256 bits of entropy. See #5.</li> </ul>"},{"location":"history/#500","title":"5.0.0","text":"<ul> <li>Breaking: Coincurve is now dual-licensed under the terms of <code>MIT</code> and <code>Apache-2.0</code></li> <li>Performance improvements from libsecp256k1 master</li> <li>Improvements to documentation.</li> </ul>"},{"location":"history/#451","title":"4.5.1","text":"<ul> <li>First public stable release</li> </ul>"},{"location":"install/","title":"Installation","text":"<p><code>coincurve</code> is available on PyPI and can be installed with pip:</p> <pre><code>pip install coincurve\n</code></pre>"},{"location":"install/#wheel","title":"Wheel","text":"<p>Binary wheels are available for most platforms and require at least version <code>19.3</code> of pip to install.</p> macOS Windows Linux (glibc) Linux (musl) CPython 3.9 <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> CPython 3.10 <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> CPython 3.11 <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> CPython 3.12 <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> CPython 3.13 <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul>"},{"location":"install/#source","title":"Source","text":"<p>If you are on a platform without support for pre-compiled wheels, you will need certain system packages in order to build from source.</p> <p>A few environment variables influence the build:</p> <ul> <li><code>COINCURVE_UPSTREAM_REF</code> - This is the Git reference of libsecp256k1 to use rather than the (frequently updated) default.</li> <li><code>COINCURVE_IGNORE_SYSTEM_LIB</code> - The presence of this will force fetching of libsecp256k1 even if it's already detected at the system level.</li> <li><code>COINCURVE_VENDOR_CFFI</code> - Setting this to anything other than <code>1</code> (the default) prevents vendoring of the <code>_cffi_backend</code> module. Re-distributors should make sure to require <code>cffi</code> as a runtime dependency when disabling this.</li> </ul> <p>Tip</p> <p>To avoid installing the binary wheels on compatible distributions, use the <code>--no-binary</code> option.</p> <pre><code>pip install coincurve --no-binary coincurve\n</code></pre>"},{"location":"install/#alpine","title":"Alpine","text":"<pre><code>sudo apk add autoconf automake build-base libffi-dev libtool pkgconfig python3-dev\n</code></pre>"},{"location":"install/#debianubuntu","title":"Debian/Ubuntu","text":"<pre><code>sudo apt-get install -y autoconf automake build-essential libffi-dev libtool pkg-config python3-dev\n</code></pre>"},{"location":"install/#rhelcentos","title":"RHEL/CentOS","text":"<pre><code>sudo yum install -y autoconf automake gcc gcc-c++ libffi-devel libtool make pkgconfig python3-devel\n</code></pre>"},{"location":"install/#macos","title":"macOS","text":"<pre><code>xcode-select --install\nbrew install autoconf automake libffi libtool pkg-config python\n</code></pre>"},{"location":"users/","title":"Users","text":""},{"location":"users/#organizations","title":"Organizations","text":"Name Projects Anyl <ul><li> anyledger-backend </li></ul> ARK <ul><li> python-crypto </li></ul> Augur <ul><li> augur-core </li></ul> Blockcerts <ul><li> cert-issuer </li></ul> ECIES <ul><li> py </li></ul> Elements <ul><li> lightning </li></ul> Ethereum <ul><li> alexandria </li><li> ddht </li><li> eth-keys </li><li> eth-tester </li><li> py-evm </li><li> pydevp2p </li><li> trinity </li></ul> Gnosis <ul><li> gnosis-py </li></ul> Golem Network <ul><li> concent </li><li> golem </li><li> golem-messages </li></ul> ICON Foundation <ul><li> goloop </li><li> icon-sdk-python </li><li> icon-service </li><li> loopchain </li><li> t-bears </li></ul> LBRY <ul><li> lbry-android-sdk </li><li> lbry-sdk </li></ul> libp2p <ul><li> py-libp2p </li></ul> Microsoft <ul><li> CCF </li></ul> NuCypher <ul><li> nucypher </li><li> nucypher-monitor </li></ul> Quantstamp <ul><li> qsp-protocol-node </li></ul> QuarkChain <ul><li> pyquarkchain </li></ul> Raiden Network <ul><li> demo-train </li><li> light-client </li><li> microraiden </li><li> raiden </li><li> raiden-contracts </li><li> raiden-service-bundle </li><li> raiden-services </li><li> raiden-wizard </li><li> raidex </li></ul> SKALE Network <ul><li> libBLS </li><li> sgx.py </li></ul>"},{"location":"users/#projects","title":"Projects","text":"<ul> <li>bit</li> <li>btcrecover</li> <li>crankycoin</li> <li>ForkDelta</li> <li>Heimdall</li> <li>HoneyBadgerBFT</li> <li>JoinMarket</li> <li>minichain</li> <li>Nekoyume</li> <li>NuCypher</li> <li>python-idex</li> <li>Rotki</li> <li>Vyper</li> <li>ZeroNet</li> </ul>"}]}