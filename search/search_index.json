{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"coincurve","text":"CI/CD Docs Package Meta <p>This library provides well-tested Python bindings for libsecp256k1, the heavily optimized C library used by Bitcoin Core for operations on the elliptic curve secp256k1.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fastest available implementation (more than 10x faster than OpenSSL)</li> <li>Clean, easy to use API</li> <li>Frequent updates from the development version of libsecp256k1</li> <li>Linux, macOS, and Windows all have binary packages for multiple architectures</li> <li>Deterministic signatures as specified by RFC 6979</li> <li>Non-malleable signatures (lower-S form) by default</li> <li>Secure, non-malleable ECDH implementation</li> </ul>"},{"location":"#users","title":"Users","text":"<ul> <li>Ethereum</li> <li>LBRY</li> <li>libp2p</li> </ul> <p>and many more!</p>"},{"location":"#license","title":"License","text":"<p><code>coincurve</code> is distributed under the terms of any of the following licenses:</p> <ul> <li>MIT</li> <li>Apache-2.0</li> </ul>"},{"location":"#navigation","title":"Navigation","text":"<p>Desktop readers can use keyboard shortcuts to navigate.</p> Keys Action <ul><li>, (comma)</li><li>p</li></ul> Navigate to the \"previous\" page <ul><li>. (period)</li><li>n</li></ul> Navigate to the \"next\" page <ul><li>/</li><li>s</li></ul> Display the search modal"},{"location":"api/","title":"Developer Interface","text":"<p>All objects are available directly under the root namespace <code>coincurve</code>.</p>"},{"location":"api/#coincurve.verify_signature","title":"<code>verify_signature(signature: bytes, message: bytes, public_key: bytes, hasher: Hasher = sha256, context: Context = GLOBAL_CONTEXT) -&gt; bool</code>","text":"<p>:param signature: The ECDSA signature. :param message: The message that was supposedly signed. :param public_key: The formatted public key. :param hasher: The hash function to use, which must return 32 bytes. By default,                the <code>sha256</code> algorithm is used. If <code>None</code>, no hashing occurs. :param context: :return: A boolean indicating whether or not the signature is correct. :raises ValueError: If the public key could not be parsed or was invalid, the message hash was                     not 32 bytes long, or the DER-encoded signature could not be parsed.</p> Source code in <code>coincurve/utils.py</code> <pre><code>def verify_signature(\n    signature: bytes, message: bytes, public_key: bytes, hasher: Hasher = sha256, context: Context = GLOBAL_CONTEXT\n) -&gt; bool:\n    \"\"\"\n    :param signature: The ECDSA signature.\n    :param message: The message that was supposedly signed.\n    :param public_key: The formatted public key.\n    :param hasher: The hash function to use, which must return 32 bytes. By default,\n                   the `sha256` algorithm is used. If `None`, no hashing occurs.\n    :param context:\n    :return: A boolean indicating whether or not the signature is correct.\n    :raises ValueError: If the public key could not be parsed or was invalid, the message hash was\n                        not 32 bytes long, or the DER-encoded signature could not be parsed.\n    \"\"\"\n    pubkey = ffi.new(\"secp256k1_pubkey *\")\n\n    pubkey_parsed = lib.secp256k1_ec_pubkey_parse(context.ctx, pubkey, public_key, len(public_key))\n\n    if not pubkey_parsed:\n        msg = \"The public key could not be parsed or is invalid.\"\n        raise ValueError(msg)\n\n    msg_hash = hasher(message) if hasher is not None else message\n    if len(msg_hash) != MSG_HASH_SIZE:\n        msg = \"Message hash must be 32 bytes long.\"\n        raise ValueError(msg)\n\n    sig = ffi.new(\"secp256k1_ecdsa_signature *\")\n\n    sig_parsed = lib.secp256k1_ecdsa_signature_parse_der(context.ctx, sig, signature, len(signature))\n\n    if not sig_parsed:\n        msg = \"The DER-encoded signature could not be parsed.\"\n        raise ValueError(msg)\n\n    verified = lib.secp256k1_ecdsa_verify(context.ctx, sig, msg_hash, pubkey)\n\n    # A performance hack to avoid global bool() lookup.\n    return not not verified  # noqa: SIM208\n</code></pre>"},{"location":"api/#coincurve.PrivateKey","title":"<code>PrivateKey</code>","text":"Source code in <code>coincurve/keys.py</code> <pre><code>class PrivateKey:\n    def __init__(self, secret: bytes | None = None, context: Context = GLOBAL_CONTEXT):\n        \"\"\"\n        :param secret: The secret used to initialize the private key.\n                       If not provided or `None`, a new key will be generated.\n        \"\"\"\n        self.secret: bytes = validate_secret(secret) if secret is not None else get_valid_secret()\n        self.context = context\n        self.public_key: PublicKey = PublicKey.from_valid_secret(self.secret, self.context)\n        self.public_key_xonly: PublicKeyXOnly = PublicKeyXOnly.from_valid_secret(self.secret, self.context)\n\n    def sign(self, message: bytes, hasher: Hasher = sha256, custom_nonce: Nonce = DEFAULT_NONCE) -&gt; bytes:\n        \"\"\"\n        Create an ECDSA signature.\n\n        :param message: The message to sign.\n        :param hasher: The hash function to use, which must return 32 bytes. By default,\n                       the `sha256` algorithm is used. If `None`, no hashing occurs.\n        :param custom_nonce: Custom nonce data in the form `(nonce_function, input_data)`. Refer to\n                             [secp256k1.h](https://github.com/bitcoin-core/secp256k1/blob/f8c0b57e6ba202b1ce7c5357688de97c9c067697/include/secp256k1.h#L546-L547).\n        :return: The ECDSA signature.\n        :raises ValueError: If the message hash was not 32 bytes long, the nonce generation\n                            function failed, or the private key was invalid.\n        \"\"\"\n        msg_hash = hasher(message) if hasher is not None else message\n        if len(msg_hash) != 32:  # noqa: PLR2004\n            msg = \"Message hash must be 32 bytes long.\"\n            raise ValueError(msg)\n\n        signature = ffi.new(\"secp256k1_ecdsa_signature *\")\n        nonce_fn, nonce_data = custom_nonce\n\n        signed = lib.secp256k1_ecdsa_sign(self.context.ctx, signature, msg_hash, self.secret, nonce_fn, nonce_data)\n\n        if not signed:\n            msg = \"The nonce generation function failed, or the private key was invalid.\"\n            raise ValueError(msg)\n\n        return cdata_to_der(signature, self.context)\n\n    def sign_schnorr(self, message: bytes, aux_randomness: bytes = b\"\") -&gt; bytes:\n        \"\"\"Create a Schnorr signature.\n\n        :param message: The message to sign.\n        :param aux_randomness: An optional 32 bytes of fresh randomness. By default (empty bytestring), this\n                               will be generated automatically. Set to `None` to disable this behavior.\n        :return: The Schnorr signature.\n        :raises ValueError: If the message was not 32 bytes long, the optional auxiliary random data was not\n                            32 bytes long, signing failed, or the signature was invalid.\n        \"\"\"\n        if len(message) != 32:  # noqa: PLR2004\n            msg = \"Message must be 32 bytes long.\"\n            raise ValueError(msg)\n        if aux_randomness == b\"\":\n            aux_randomness = os.urandom(32)\n        elif aux_randomness is None:\n            aux_randomness = ffi.NULL\n        elif len(aux_randomness) != 32:  # noqa: PLR2004\n            msg = \"Auxiliary random data must be 32 bytes long.\"\n            raise ValueError(msg)\n\n        keypair = ffi.new(\"secp256k1_keypair *\")\n        res = lib.secp256k1_keypair_create(self.context.ctx, keypair, self.secret)\n        if not res:\n            msg = \"Secret was invalid\"\n            raise ValueError(msg)\n\n        signature = ffi.new(\"unsigned char[64]\")\n        res = lib.secp256k1_schnorrsig_sign32(self.context.ctx, signature, message, keypair, aux_randomness)\n        if not res:\n            msg = \"Signing failed\"\n            raise ValueError(msg)\n\n        res = lib.secp256k1_schnorrsig_verify(\n            self.context.ctx, signature, message, len(message), self.public_key_xonly.public_key\n        )\n        if not res:\n            msg = \"Invalid signature\"\n            raise ValueError(msg)\n\n        return bytes(ffi.buffer(signature))\n\n    def sign_recoverable(self, message: bytes, hasher: Hasher = sha256, custom_nonce: Nonce = DEFAULT_NONCE) -&gt; bytes:\n        \"\"\"\n        Create a recoverable ECDSA signature.\n\n        :param message: The message to sign.\n        :param hasher: The hash function to use, which must return 32 bytes. By default,\n                       the `sha256` algorithm is used. If `None`, no hashing occurs.\n        :param custom_nonce: Custom nonce data in the form `(nonce_function, input_data)`. Refer to\n                             [secp256k1_recovery.h](https://github.com/bitcoin-core/secp256k1/blob/f8c0b57e6ba202b1ce7c5357688de97c9c067697/include/secp256k1_recovery.h#L78-L79).\n        :return: The recoverable ECDSA signature.\n        :raises ValueError: If the message hash was not 32 bytes long, the nonce generation\n                            function failed, or the private key was invalid.\n        \"\"\"\n        msg_hash = hasher(message) if hasher is not None else message\n        if len(msg_hash) != 32:  # noqa: PLR2004\n            msg = \"Message hash must be 32 bytes long.\"\n            raise ValueError(msg)\n\n        signature = ffi.new(\"secp256k1_ecdsa_recoverable_signature *\")\n        nonce_fn, nonce_data = custom_nonce\n\n        signed = lib.secp256k1_ecdsa_sign_recoverable(\n            self.context.ctx, signature, msg_hash, self.secret, nonce_fn, nonce_data\n        )\n\n        if not signed:\n            msg = \"The nonce generation function failed, or the private key was invalid.\"\n            raise ValueError(msg)\n\n        return serialize_recoverable(signature, self.context)\n\n    def ecdh(self, public_key: bytes) -&gt; bytes:\n        \"\"\"\n        Compute an EC Diffie-Hellman secret in constant time.\n\n        !!! note\n            This prevents malleability by returning `sha256(compressed_public_key)` instead of the `x` coordinate\n            directly. See #9.\n\n        :param public_key: The formatted public key.\n        :return: The 32 byte shared secret.\n        :raises ValueError: If the public key could not be parsed or was invalid.\n        \"\"\"\n        secret = ffi.new(\"unsigned char [32]\")\n\n        lib.secp256k1_ecdh(self.context.ctx, secret, PublicKey(public_key).public_key, self.secret, ffi.NULL, ffi.NULL)\n\n        return bytes(ffi.buffer(secret, 32))\n\n    def add(self, scalar: bytes, update: bool = False):  # noqa: FBT001, FBT002\n        \"\"\"\n        Add a scalar to the private key.\n\n        :param scalar: The scalar with which to add.\n        :param update: Whether or not to update and return the private key in-place.\n        :return: The new private key, or the modified private key if `update` is `True`.\n        :rtype: PrivateKey\n        :raises ValueError: If the tweak was out of range or the resulting private key was invalid.\n        \"\"\"\n        scalar = pad_scalar(scalar)\n\n        secret = ffi.new(\"unsigned char [32]\", self.secret)\n\n        success = lib.secp256k1_ec_seckey_tweak_add(self.context.ctx, secret, scalar)\n\n        if not success:\n            msg = \"The tweak was out of range, or the resulting private key is invalid.\"\n            raise ValueError(msg)\n\n        secret = bytes(ffi.buffer(secret, 32))\n\n        if update:\n            self.secret = secret\n            self._update_public_key()\n            return self\n\n        return PrivateKey(secret, self.context)\n\n    def multiply(self, scalar: bytes, update: bool = False):  # noqa: FBT001, FBT002\n        \"\"\"\n        Multiply the private key by a scalar.\n\n        :param scalar: The scalar with which to multiply.\n        :param update: Whether or not to update and return the private key in-place.\n        :return: The new private key, or the modified private key if `update` is `True`.\n        :rtype: PrivateKey\n        \"\"\"\n        scalar = validate_secret(scalar)\n\n        secret = ffi.new(\"unsigned char [32]\", self.secret)\n\n        lib.secp256k1_ec_seckey_tweak_mul(self.context.ctx, secret, scalar)\n\n        secret = bytes(ffi.buffer(secret, 32))\n\n        if update:\n            self.secret = secret\n            self._update_public_key()\n            return self\n\n        return PrivateKey(secret, self.context)\n\n    def to_hex(self) -&gt; str:\n        \"\"\"\n        :return: The private key encoded as a hex string.\n        \"\"\"\n        return self.secret.hex()\n\n    def to_int(self) -&gt; int:\n        \"\"\"\n        :return: The private key as an integer.\n        \"\"\"\n        return bytes_to_int(self.secret)\n\n    def to_pem(self) -&gt; bytes:\n        \"\"\"\n        :return: The private key encoded in PEM format.\n        \"\"\"\n        return der_to_pem(self.to_der())\n\n    def to_der(self) -&gt; bytes:\n        \"\"\"\n        :return: The private key encoded in DER format.\n        \"\"\"\n        pk = ECPrivateKey({\n            \"version\": \"ecPrivkeyVer1\",\n            \"private_key\": self.to_int(),\n            \"public_key\": ECPointBitString(self.public_key.format(compressed=False)),\n        })\n\n        return PrivateKeyInfo({\n            \"version\": 0,\n            \"private_key_algorithm\": PrivateKeyAlgorithm({\n                \"algorithm\": \"ec\",\n                \"parameters\": ECDomainParameters(name=\"named\", value=\"1.3.132.0.10\"),\n            }),\n            \"private_key\": pk,\n        }).dump()\n\n    @classmethod\n    def from_hex(cls, hexed: str, context: Context = GLOBAL_CONTEXT):\n        \"\"\"\n        :param hexed: The private key encoded as a hex string.\n        :param context:\n        :return: The private key.\n        :rtype: PrivateKey\n        \"\"\"\n        return PrivateKey(hex_to_bytes(hexed), context)\n\n    @classmethod\n    def from_int(cls, num: int, context: Context = GLOBAL_CONTEXT):\n        \"\"\"\n        :param num: The private key as an integer.\n        :param context:\n        :return: The private key.\n        :rtype: PrivateKey\n        \"\"\"\n        return PrivateKey(int_to_bytes_padded(num), context)\n\n    @classmethod\n    def from_pem(cls, pem: bytes, context: Context = GLOBAL_CONTEXT):\n        \"\"\"\n        :param pem: The private key encoded in PEM format.\n        :param context:\n        :return: The private key.\n        :rtype: PrivateKey\n        \"\"\"\n        return PrivateKey(\n            int_to_bytes_padded(PrivateKeyInfo.load(pem_to_der(pem)).native[\"private_key\"][\"private_key\"]), context\n        )\n\n    @classmethod\n    def from_der(cls, der: bytes, context: Context = GLOBAL_CONTEXT):\n        \"\"\"\n        :param der: The private key encoded in DER format.\n        :param context:\n        :return: The private key.\n        :rtype: PrivateKey\n        \"\"\"\n        return PrivateKey(int_to_bytes_padded(PrivateKeyInfo.load(der).native[\"private_key\"][\"private_key\"]), context)\n\n    def _update_public_key(self):\n        created = lib.secp256k1_ec_pubkey_create(self.context.ctx, self.public_key.public_key, self.secret)\n\n        if not created:\n            msg = \"Invalid secret.\"\n            raise ValueError(msg)\n\n    def __eq__(self, other) -&gt; bool:\n        return self.secret == other.secret\n\n    def __hash__(self) -&gt; int:\n        return hash(self.secret)\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.context","title":"<code>context = context</code>  <code>instance-attribute</code>","text":""},{"location":"api/#coincurve.PrivateKey.public_key","title":"<code>public_key: PublicKey = PublicKey.from_valid_secret(self.secret, self.context)</code>  <code>instance-attribute</code>","text":""},{"location":"api/#coincurve.PrivateKey.public_key_xonly","title":"<code>public_key_xonly: PublicKeyXOnly = PublicKeyXOnly.from_valid_secret(self.secret, self.context)</code>  <code>instance-attribute</code>","text":""},{"location":"api/#coincurve.PrivateKey.secret","title":"<code>secret: bytes = validate_secret(secret) if secret is not None else get_valid_secret()</code>  <code>instance-attribute</code>","text":""},{"location":"api/#coincurve.PrivateKey.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>coincurve/keys.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    return self.secret == other.secret\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"Source code in <code>coincurve/keys.py</code> <pre><code>def __hash__(self) -&gt; int:\n    return hash(self.secret)\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.__init__","title":"<code>__init__(secret: bytes | None = None, context: Context = GLOBAL_CONTEXT)</code>","text":"<p>:param secret: The secret used to initialize the private key.                If not provided or <code>None</code>, a new key will be generated.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def __init__(self, secret: bytes | None = None, context: Context = GLOBAL_CONTEXT):\n    \"\"\"\n    :param secret: The secret used to initialize the private key.\n                   If not provided or `None`, a new key will be generated.\n    \"\"\"\n    self.secret: bytes = validate_secret(secret) if secret is not None else get_valid_secret()\n    self.context = context\n    self.public_key: PublicKey = PublicKey.from_valid_secret(self.secret, self.context)\n    self.public_key_xonly: PublicKeyXOnly = PublicKeyXOnly.from_valid_secret(self.secret, self.context)\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.add","title":"<code>add(scalar: bytes, update: bool = False)</code>","text":"<p>Add a scalar to the private key.</p> <p>:param scalar: The scalar with which to add. :param update: Whether or not to update and return the private key in-place. :return: The new private key, or the modified private key if <code>update</code> is <code>True</code>. :rtype: PrivateKey :raises ValueError: If the tweak was out of range or the resulting private key was invalid.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def add(self, scalar: bytes, update: bool = False):  # noqa: FBT001, FBT002\n    \"\"\"\n    Add a scalar to the private key.\n\n    :param scalar: The scalar with which to add.\n    :param update: Whether or not to update and return the private key in-place.\n    :return: The new private key, or the modified private key if `update` is `True`.\n    :rtype: PrivateKey\n    :raises ValueError: If the tweak was out of range or the resulting private key was invalid.\n    \"\"\"\n    scalar = pad_scalar(scalar)\n\n    secret = ffi.new(\"unsigned char [32]\", self.secret)\n\n    success = lib.secp256k1_ec_seckey_tweak_add(self.context.ctx, secret, scalar)\n\n    if not success:\n        msg = \"The tweak was out of range, or the resulting private key is invalid.\"\n        raise ValueError(msg)\n\n    secret = bytes(ffi.buffer(secret, 32))\n\n    if update:\n        self.secret = secret\n        self._update_public_key()\n        return self\n\n    return PrivateKey(secret, self.context)\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.ecdh","title":"<code>ecdh(public_key: bytes) -&gt; bytes</code>","text":"<p>Compute an EC Diffie-Hellman secret in constant time.</p> <p>Note</p> <p>This prevents malleability by returning <code>sha256(compressed_public_key)</code> instead of the <code>x</code> coordinate directly. See #9.</p> <p>:param public_key: The formatted public key. :return: The 32 byte shared secret. :raises ValueError: If the public key could not be parsed or was invalid.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def ecdh(self, public_key: bytes) -&gt; bytes:\n    \"\"\"\n    Compute an EC Diffie-Hellman secret in constant time.\n\n    !!! note\n        This prevents malleability by returning `sha256(compressed_public_key)` instead of the `x` coordinate\n        directly. See #9.\n\n    :param public_key: The formatted public key.\n    :return: The 32 byte shared secret.\n    :raises ValueError: If the public key could not be parsed or was invalid.\n    \"\"\"\n    secret = ffi.new(\"unsigned char [32]\")\n\n    lib.secp256k1_ecdh(self.context.ctx, secret, PublicKey(public_key).public_key, self.secret, ffi.NULL, ffi.NULL)\n\n    return bytes(ffi.buffer(secret, 32))\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.from_der","title":"<code>from_der(der: bytes, context: Context = GLOBAL_CONTEXT)</code>  <code>classmethod</code>","text":"<p>:param der: The private key encoded in DER format. :param context: :return: The private key. :rtype: PrivateKey</p> Source code in <code>coincurve/keys.py</code> <pre><code>@classmethod\ndef from_der(cls, der: bytes, context: Context = GLOBAL_CONTEXT):\n    \"\"\"\n    :param der: The private key encoded in DER format.\n    :param context:\n    :return: The private key.\n    :rtype: PrivateKey\n    \"\"\"\n    return PrivateKey(int_to_bytes_padded(PrivateKeyInfo.load(der).native[\"private_key\"][\"private_key\"]), context)\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.from_hex","title":"<code>from_hex(hexed: str, context: Context = GLOBAL_CONTEXT)</code>  <code>classmethod</code>","text":"<p>:param hexed: The private key encoded as a hex string. :param context: :return: The private key. :rtype: PrivateKey</p> Source code in <code>coincurve/keys.py</code> <pre><code>@classmethod\ndef from_hex(cls, hexed: str, context: Context = GLOBAL_CONTEXT):\n    \"\"\"\n    :param hexed: The private key encoded as a hex string.\n    :param context:\n    :return: The private key.\n    :rtype: PrivateKey\n    \"\"\"\n    return PrivateKey(hex_to_bytes(hexed), context)\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.from_int","title":"<code>from_int(num: int, context: Context = GLOBAL_CONTEXT)</code>  <code>classmethod</code>","text":"<p>:param num: The private key as an integer. :param context: :return: The private key. :rtype: PrivateKey</p> Source code in <code>coincurve/keys.py</code> <pre><code>@classmethod\ndef from_int(cls, num: int, context: Context = GLOBAL_CONTEXT):\n    \"\"\"\n    :param num: The private key as an integer.\n    :param context:\n    :return: The private key.\n    :rtype: PrivateKey\n    \"\"\"\n    return PrivateKey(int_to_bytes_padded(num), context)\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.from_pem","title":"<code>from_pem(pem: bytes, context: Context = GLOBAL_CONTEXT)</code>  <code>classmethod</code>","text":"<p>:param pem: The private key encoded in PEM format. :param context: :return: The private key. :rtype: PrivateKey</p> Source code in <code>coincurve/keys.py</code> <pre><code>@classmethod\ndef from_pem(cls, pem: bytes, context: Context = GLOBAL_CONTEXT):\n    \"\"\"\n    :param pem: The private key encoded in PEM format.\n    :param context:\n    :return: The private key.\n    :rtype: PrivateKey\n    \"\"\"\n    return PrivateKey(\n        int_to_bytes_padded(PrivateKeyInfo.load(pem_to_der(pem)).native[\"private_key\"][\"private_key\"]), context\n    )\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.multiply","title":"<code>multiply(scalar: bytes, update: bool = False)</code>","text":"<p>Multiply the private key by a scalar.</p> <p>:param scalar: The scalar with which to multiply. :param update: Whether or not to update and return the private key in-place. :return: The new private key, or the modified private key if <code>update</code> is <code>True</code>. :rtype: PrivateKey</p> Source code in <code>coincurve/keys.py</code> <pre><code>def multiply(self, scalar: bytes, update: bool = False):  # noqa: FBT001, FBT002\n    \"\"\"\n    Multiply the private key by a scalar.\n\n    :param scalar: The scalar with which to multiply.\n    :param update: Whether or not to update and return the private key in-place.\n    :return: The new private key, or the modified private key if `update` is `True`.\n    :rtype: PrivateKey\n    \"\"\"\n    scalar = validate_secret(scalar)\n\n    secret = ffi.new(\"unsigned char [32]\", self.secret)\n\n    lib.secp256k1_ec_seckey_tweak_mul(self.context.ctx, secret, scalar)\n\n    secret = bytes(ffi.buffer(secret, 32))\n\n    if update:\n        self.secret = secret\n        self._update_public_key()\n        return self\n\n    return PrivateKey(secret, self.context)\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.sign","title":"<code>sign(message: bytes, hasher: Hasher = sha256, custom_nonce: Nonce = DEFAULT_NONCE) -&gt; bytes</code>","text":"<p>Create an ECDSA signature.</p> <p>:param message: The message to sign. :param hasher: The hash function to use, which must return 32 bytes. By default,                the <code>sha256</code> algorithm is used. If <code>None</code>, no hashing occurs. :param custom_nonce: Custom nonce data in the form <code>(nonce_function, input_data)</code>. Refer to                      secp256k1.h. :return: The ECDSA signature. :raises ValueError: If the message hash was not 32 bytes long, the nonce generation                     function failed, or the private key was invalid.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def sign(self, message: bytes, hasher: Hasher = sha256, custom_nonce: Nonce = DEFAULT_NONCE) -&gt; bytes:\n    \"\"\"\n    Create an ECDSA signature.\n\n    :param message: The message to sign.\n    :param hasher: The hash function to use, which must return 32 bytes. By default,\n                   the `sha256` algorithm is used. If `None`, no hashing occurs.\n    :param custom_nonce: Custom nonce data in the form `(nonce_function, input_data)`. Refer to\n                         [secp256k1.h](https://github.com/bitcoin-core/secp256k1/blob/f8c0b57e6ba202b1ce7c5357688de97c9c067697/include/secp256k1.h#L546-L547).\n    :return: The ECDSA signature.\n    :raises ValueError: If the message hash was not 32 bytes long, the nonce generation\n                        function failed, or the private key was invalid.\n    \"\"\"\n    msg_hash = hasher(message) if hasher is not None else message\n    if len(msg_hash) != 32:  # noqa: PLR2004\n        msg = \"Message hash must be 32 bytes long.\"\n        raise ValueError(msg)\n\n    signature = ffi.new(\"secp256k1_ecdsa_signature *\")\n    nonce_fn, nonce_data = custom_nonce\n\n    signed = lib.secp256k1_ecdsa_sign(self.context.ctx, signature, msg_hash, self.secret, nonce_fn, nonce_data)\n\n    if not signed:\n        msg = \"The nonce generation function failed, or the private key was invalid.\"\n        raise ValueError(msg)\n\n    return cdata_to_der(signature, self.context)\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.sign_recoverable","title":"<code>sign_recoverable(message: bytes, hasher: Hasher = sha256, custom_nonce: Nonce = DEFAULT_NONCE) -&gt; bytes</code>","text":"<p>Create a recoverable ECDSA signature.</p> <p>:param message: The message to sign. :param hasher: The hash function to use, which must return 32 bytes. By default,                the <code>sha256</code> algorithm is used. If <code>None</code>, no hashing occurs. :param custom_nonce: Custom nonce data in the form <code>(nonce_function, input_data)</code>. Refer to                      secp256k1_recovery.h. :return: The recoverable ECDSA signature. :raises ValueError: If the message hash was not 32 bytes long, the nonce generation                     function failed, or the private key was invalid.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def sign_recoverable(self, message: bytes, hasher: Hasher = sha256, custom_nonce: Nonce = DEFAULT_NONCE) -&gt; bytes:\n    \"\"\"\n    Create a recoverable ECDSA signature.\n\n    :param message: The message to sign.\n    :param hasher: The hash function to use, which must return 32 bytes. By default,\n                   the `sha256` algorithm is used. If `None`, no hashing occurs.\n    :param custom_nonce: Custom nonce data in the form `(nonce_function, input_data)`. Refer to\n                         [secp256k1_recovery.h](https://github.com/bitcoin-core/secp256k1/blob/f8c0b57e6ba202b1ce7c5357688de97c9c067697/include/secp256k1_recovery.h#L78-L79).\n    :return: The recoverable ECDSA signature.\n    :raises ValueError: If the message hash was not 32 bytes long, the nonce generation\n                        function failed, or the private key was invalid.\n    \"\"\"\n    msg_hash = hasher(message) if hasher is not None else message\n    if len(msg_hash) != 32:  # noqa: PLR2004\n        msg = \"Message hash must be 32 bytes long.\"\n        raise ValueError(msg)\n\n    signature = ffi.new(\"secp256k1_ecdsa_recoverable_signature *\")\n    nonce_fn, nonce_data = custom_nonce\n\n    signed = lib.secp256k1_ecdsa_sign_recoverable(\n        self.context.ctx, signature, msg_hash, self.secret, nonce_fn, nonce_data\n    )\n\n    if not signed:\n        msg = \"The nonce generation function failed, or the private key was invalid.\"\n        raise ValueError(msg)\n\n    return serialize_recoverable(signature, self.context)\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.sign_schnorr","title":"<code>sign_schnorr(message: bytes, aux_randomness: bytes = b'') -&gt; bytes</code>","text":"<p>Create a Schnorr signature.</p> <p>:param message: The message to sign. :param aux_randomness: An optional 32 bytes of fresh randomness. By default (empty bytestring), this                        will be generated automatically. Set to <code>None</code> to disable this behavior. :return: The Schnorr signature. :raises ValueError: If the message was not 32 bytes long, the optional auxiliary random data was not                     32 bytes long, signing failed, or the signature was invalid.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def sign_schnorr(self, message: bytes, aux_randomness: bytes = b\"\") -&gt; bytes:\n    \"\"\"Create a Schnorr signature.\n\n    :param message: The message to sign.\n    :param aux_randomness: An optional 32 bytes of fresh randomness. By default (empty bytestring), this\n                           will be generated automatically. Set to `None` to disable this behavior.\n    :return: The Schnorr signature.\n    :raises ValueError: If the message was not 32 bytes long, the optional auxiliary random data was not\n                        32 bytes long, signing failed, or the signature was invalid.\n    \"\"\"\n    if len(message) != 32:  # noqa: PLR2004\n        msg = \"Message must be 32 bytes long.\"\n        raise ValueError(msg)\n    if aux_randomness == b\"\":\n        aux_randomness = os.urandom(32)\n    elif aux_randomness is None:\n        aux_randomness = ffi.NULL\n    elif len(aux_randomness) != 32:  # noqa: PLR2004\n        msg = \"Auxiliary random data must be 32 bytes long.\"\n        raise ValueError(msg)\n\n    keypair = ffi.new(\"secp256k1_keypair *\")\n    res = lib.secp256k1_keypair_create(self.context.ctx, keypair, self.secret)\n    if not res:\n        msg = \"Secret was invalid\"\n        raise ValueError(msg)\n\n    signature = ffi.new(\"unsigned char[64]\")\n    res = lib.secp256k1_schnorrsig_sign32(self.context.ctx, signature, message, keypair, aux_randomness)\n    if not res:\n        msg = \"Signing failed\"\n        raise ValueError(msg)\n\n    res = lib.secp256k1_schnorrsig_verify(\n        self.context.ctx, signature, message, len(message), self.public_key_xonly.public_key\n    )\n    if not res:\n        msg = \"Invalid signature\"\n        raise ValueError(msg)\n\n    return bytes(ffi.buffer(signature))\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.to_der","title":"<code>to_der() -&gt; bytes</code>","text":"<p>:return: The private key encoded in DER format.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def to_der(self) -&gt; bytes:\n    \"\"\"\n    :return: The private key encoded in DER format.\n    \"\"\"\n    pk = ECPrivateKey({\n        \"version\": \"ecPrivkeyVer1\",\n        \"private_key\": self.to_int(),\n        \"public_key\": ECPointBitString(self.public_key.format(compressed=False)),\n    })\n\n    return PrivateKeyInfo({\n        \"version\": 0,\n        \"private_key_algorithm\": PrivateKeyAlgorithm({\n            \"algorithm\": \"ec\",\n            \"parameters\": ECDomainParameters(name=\"named\", value=\"1.3.132.0.10\"),\n        }),\n        \"private_key\": pk,\n    }).dump()\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.to_hex","title":"<code>to_hex() -&gt; str</code>","text":"<p>:return: The private key encoded as a hex string.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def to_hex(self) -&gt; str:\n    \"\"\"\n    :return: The private key encoded as a hex string.\n    \"\"\"\n    return self.secret.hex()\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.to_int","title":"<code>to_int() -&gt; int</code>","text":"<p>:return: The private key as an integer.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def to_int(self) -&gt; int:\n    \"\"\"\n    :return: The private key as an integer.\n    \"\"\"\n    return bytes_to_int(self.secret)\n</code></pre>"},{"location":"api/#coincurve.PrivateKey.to_pem","title":"<code>to_pem() -&gt; bytes</code>","text":"<p>:return: The private key encoded in PEM format.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def to_pem(self) -&gt; bytes:\n    \"\"\"\n    :return: The private key encoded in PEM format.\n    \"\"\"\n    return der_to_pem(self.to_der())\n</code></pre>"},{"location":"api/#coincurve.PublicKey","title":"<code>PublicKey</code>","text":"Source code in <code>coincurve/keys.py</code> <pre><code>class PublicKey:\n    def __init__(self, data, context: Context = GLOBAL_CONTEXT):\n        \"\"\"\n        :param data: The formatted public key. This class supports parsing\n                     compressed (33 bytes, header byte `0x02` or `0x03`),\n                     uncompressed (65 bytes, header byte `0x04`), or\n                     hybrid (65 bytes, header byte `0x06` or `0x07`) format public keys.\n        :type data: bytes\n        :param context:\n        :raises ValueError: If the public key could not be parsed or was invalid.\n        \"\"\"\n        if not isinstance(data, bytes):\n            self.public_key = data\n        else:\n            public_key = ffi.new(\"secp256k1_pubkey *\")\n\n            parsed = lib.secp256k1_ec_pubkey_parse(context.ctx, public_key, data, len(data))\n\n            if not parsed:\n                msg = \"The public key could not be parsed or is invalid.\"\n                raise ValueError(msg)\n\n            self.public_key = public_key\n\n        self.context = context\n\n    @classmethod\n    def from_secret(cls, secret: bytes, context: Context = GLOBAL_CONTEXT):\n        \"\"\"\n        Derive a public key from a private key secret.\n\n        :param secret: The private key secret.\n        :param context:\n        :return: The public key.\n        :rtype: PublicKey\n        \"\"\"\n        public_key = ffi.new(\"secp256k1_pubkey *\")\n\n        created = lib.secp256k1_ec_pubkey_create(context.ctx, public_key, validate_secret(secret))\n\n        if not created:  # no cov\n            msg = (\n                \"Somehow an invalid secret was used. Please \"\n                \"submit this as an issue here: \"\n                \"https://github.com/ofek/coincurve/issues/new\"\n            )\n            raise ValueError(msg)\n\n        return PublicKey(public_key, context)\n\n    @classmethod\n    def from_valid_secret(cls, secret: bytes, context: Context = GLOBAL_CONTEXT):\n        public_key = ffi.new(\"secp256k1_pubkey *\")\n\n        created = lib.secp256k1_ec_pubkey_create(context.ctx, public_key, secret)\n\n        if not created:\n            msg = \"Invalid secret.\"\n            raise ValueError(msg)\n\n        return PublicKey(public_key, context)\n\n    @classmethod\n    def from_point(cls, x: int, y: int, context: Context = GLOBAL_CONTEXT):\n        \"\"\"\n        Derive a public key from a coordinate point in the form `(x, y)`.\n\n        :param x:\n        :param y:\n        :param context:\n        :return: The public key.\n        :rtype: PublicKey\n        \"\"\"\n        return PublicKey(b\"\\x04\" + int_to_bytes_padded(x) + int_to_bytes_padded(y), context)\n\n    @classmethod\n    def from_signature_and_message(\n        cls, signature: bytes, message: bytes, hasher: Hasher = sha256, context: Context = GLOBAL_CONTEXT\n    ):\n        \"\"\"\n        Recover an ECDSA public key from a recoverable signature.\n\n        :param signature: The recoverable ECDSA signature.\n        :param message: The message that was supposedly signed.\n        :param hasher: The hash function to use, which must return 32 bytes. By default,\n                       the `sha256` algorithm is used. If `None`, no hashing occurs.\n        :param context:\n        :return: The public key that signed the message.\n        :rtype: PublicKey\n        :raises ValueError: If the message hash was not 32 bytes long or recovery of the ECDSA public key failed.\n        \"\"\"\n        return PublicKey(\n            recover(message, deserialize_recoverable(signature, context=context), hasher=hasher, context=context)\n        )\n\n    @classmethod\n    def combine_keys(cls, public_keys, context: Context = GLOBAL_CONTEXT):\n        \"\"\"\n        Add a number of public keys together.\n\n        :param public_keys: A sequence of public keys.\n        :type public_keys: List[PublicKey]\n        :param context:\n        :return: The combined public key.\n        :rtype: PublicKey\n        :raises ValueError: If the sum of the public keys was invalid.\n        \"\"\"\n        public_key = ffi.new(\"secp256k1_pubkey *\")\n\n        combined = lib.secp256k1_ec_pubkey_combine(\n            context.ctx, public_key, [pk.public_key for pk in public_keys], len(public_keys)\n        )\n\n        if not combined:\n            msg = \"The sum of the public keys is invalid.\"\n            raise ValueError(msg)\n\n        return PublicKey(public_key, context)\n\n    def format(self, compressed: bool = True) -&gt; bytes:  # noqa: FBT001, FBT002\n        \"\"\"\n        Format the public key.\n\n        :param compressed: Whether or to use the compressed format.\n        :return: The 33 byte formatted public key, or the 65 byte formatted public key if `compressed` is `False`.\n        \"\"\"\n        length = 33 if compressed else 65\n        serialized = ffi.new(\"unsigned char [%d]\" % length)  # noqa: UP031\n        output_len = ffi.new(\"size_t *\", length)\n\n        lib.secp256k1_ec_pubkey_serialize(\n            self.context.ctx, serialized, output_len, self.public_key, EC_COMPRESSED if compressed else EC_UNCOMPRESSED\n        )\n\n        return bytes(ffi.buffer(serialized, length))\n\n    def point(self) -&gt; tuple[int, int]:\n        \"\"\"\n        :return: The public key as a coordinate point.\n        \"\"\"\n        public_key = self.format(compressed=False)\n        return bytes_to_int(public_key[1:33]), bytes_to_int(public_key[33:])\n\n    def verify(self, signature: bytes, message: bytes, hasher: Hasher = sha256) -&gt; bool:\n        \"\"\"\n        :param signature: The ECDSA signature.\n        :param message: The message that was supposedly signed.\n        :param hasher: The hash function to use, which must return 32 bytes. By default,\n                       the `sha256` algorithm is used. If `None`, no hashing occurs.\n        :return: A boolean indicating whether or not the signature is correct.\n        :raises ValueError: If the message hash was not 32 bytes long or the DER-encoded signature could not be parsed.\n        \"\"\"\n        msg_hash = hasher(message) if hasher is not None else message\n        if len(msg_hash) != 32:  # noqa: PLR2004\n            msg = \"Message hash must be 32 bytes long.\"\n            raise ValueError(msg)\n\n        verified = lib.secp256k1_ecdsa_verify(self.context.ctx, der_to_cdata(signature), msg_hash, self.public_key)\n\n        # A performance hack to avoid global bool() lookup.\n        return not not verified  # noqa: SIM208\n\n    def add(self, scalar: bytes, update: bool = False):  # noqa: FBT001, FBT002\n        \"\"\"\n        Add a scalar to the public key.\n\n        :param scalar: The scalar with which to add.\n        :param update: Whether or not to update and return the public key in-place.\n        :return: The new public key, or the modified public key if `update` is `True`.\n        :rtype: PublicKey\n        :raises ValueError: If the tweak was out of range or the resulting public key was invalid.\n        \"\"\"\n        scalar = pad_scalar(scalar)\n\n        new_key = ffi.new(\"secp256k1_pubkey *\", self.public_key[0])\n\n        success = lib.secp256k1_ec_pubkey_tweak_add(self.context.ctx, new_key, scalar)\n\n        if not success:\n            msg = \"The tweak was out of range, or the resulting public key is invalid.\"\n            raise ValueError(msg)\n\n        if update:\n            self.public_key = new_key\n            return self\n\n        return PublicKey(new_key, self.context)\n\n    def multiply(self, scalar: bytes, update: bool = False):  # noqa: FBT001, FBT002\n        \"\"\"\n        Multiply the public key by a scalar.\n\n        :param scalar: The scalar with which to multiply.\n        :param update: Whether or not to update and return the public key in-place.\n        :return: The new public key, or the modified public key if `update` is `True`.\n        :rtype: PublicKey\n        \"\"\"\n        scalar = validate_secret(scalar)\n\n        new_key = ffi.new(\"secp256k1_pubkey *\", self.public_key[0])\n\n        lib.secp256k1_ec_pubkey_tweak_mul(self.context.ctx, new_key, scalar)\n\n        if update:\n            self.public_key = new_key\n            return self\n\n        return PublicKey(new_key, self.context)\n\n    def combine(self, public_keys, update: bool = False):  # noqa: FBT001, FBT002\n        \"\"\"\n        Add a number of public keys together.\n\n        :param public_keys: A sequence of public keys.\n        :type public_keys: List[PublicKey]\n        :param update: Whether or not to update and return the public key in-place.\n        :return: The combined public key, or the modified public key if `update` is `True`.\n        :rtype: PublicKey\n        :raises ValueError: If the sum of the public keys was invalid.\n        \"\"\"\n        new_key = ffi.new(\"secp256k1_pubkey *\")\n\n        combined = lib.secp256k1_ec_pubkey_combine(\n            self.context.ctx, new_key, [pk.public_key for pk in [self, *public_keys]], len(public_keys) + 1\n        )\n\n        if not combined:\n            msg = \"The sum of the public keys is invalid.\"\n            raise ValueError(msg)\n\n        if update:\n            self.public_key = new_key\n            return self\n\n        return PublicKey(new_key, self.context)\n\n    def __eq__(self, other) -&gt; bool:\n        return self.format(compressed=False) == other.format(compressed=False)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.format(compressed=False))\n</code></pre>"},{"location":"api/#coincurve.PublicKey.context","title":"<code>context = context</code>  <code>instance-attribute</code>","text":""},{"location":"api/#coincurve.PublicKey.public_key","title":"<code>public_key = data</code>  <code>instance-attribute</code>","text":""},{"location":"api/#coincurve.PublicKey.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>coincurve/keys.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    return self.format(compressed=False) == other.format(compressed=False)\n</code></pre>"},{"location":"api/#coincurve.PublicKey.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"Source code in <code>coincurve/keys.py</code> <pre><code>def __hash__(self) -&gt; int:\n    return hash(self.format(compressed=False))\n</code></pre>"},{"location":"api/#coincurve.PublicKey.__init__","title":"<code>__init__(data, context: Context = GLOBAL_CONTEXT)</code>","text":"<p>:param data: The formatted public key. This class supports parsing              compressed (33 bytes, header byte <code>0x02</code> or <code>0x03</code>),              uncompressed (65 bytes, header byte <code>0x04</code>), or              hybrid (65 bytes, header byte <code>0x06</code> or <code>0x07</code>) format public keys. :type data: bytes :param context: :raises ValueError: If the public key could not be parsed or was invalid.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def __init__(self, data, context: Context = GLOBAL_CONTEXT):\n    \"\"\"\n    :param data: The formatted public key. This class supports parsing\n                 compressed (33 bytes, header byte `0x02` or `0x03`),\n                 uncompressed (65 bytes, header byte `0x04`), or\n                 hybrid (65 bytes, header byte `0x06` or `0x07`) format public keys.\n    :type data: bytes\n    :param context:\n    :raises ValueError: If the public key could not be parsed or was invalid.\n    \"\"\"\n    if not isinstance(data, bytes):\n        self.public_key = data\n    else:\n        public_key = ffi.new(\"secp256k1_pubkey *\")\n\n        parsed = lib.secp256k1_ec_pubkey_parse(context.ctx, public_key, data, len(data))\n\n        if not parsed:\n            msg = \"The public key could not be parsed or is invalid.\"\n            raise ValueError(msg)\n\n        self.public_key = public_key\n\n    self.context = context\n</code></pre>"},{"location":"api/#coincurve.PublicKey.add","title":"<code>add(scalar: bytes, update: bool = False)</code>","text":"<p>Add a scalar to the public key.</p> <p>:param scalar: The scalar with which to add. :param update: Whether or not to update and return the public key in-place. :return: The new public key, or the modified public key if <code>update</code> is <code>True</code>. :rtype: PublicKey :raises ValueError: If the tweak was out of range or the resulting public key was invalid.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def add(self, scalar: bytes, update: bool = False):  # noqa: FBT001, FBT002\n    \"\"\"\n    Add a scalar to the public key.\n\n    :param scalar: The scalar with which to add.\n    :param update: Whether or not to update and return the public key in-place.\n    :return: The new public key, or the modified public key if `update` is `True`.\n    :rtype: PublicKey\n    :raises ValueError: If the tweak was out of range or the resulting public key was invalid.\n    \"\"\"\n    scalar = pad_scalar(scalar)\n\n    new_key = ffi.new(\"secp256k1_pubkey *\", self.public_key[0])\n\n    success = lib.secp256k1_ec_pubkey_tweak_add(self.context.ctx, new_key, scalar)\n\n    if not success:\n        msg = \"The tweak was out of range, or the resulting public key is invalid.\"\n        raise ValueError(msg)\n\n    if update:\n        self.public_key = new_key\n        return self\n\n    return PublicKey(new_key, self.context)\n</code></pre>"},{"location":"api/#coincurve.PublicKey.combine","title":"<code>combine(public_keys, update: bool = False)</code>","text":"<p>Add a number of public keys together.</p> <p>:param public_keys: A sequence of public keys. :type public_keys: List[PublicKey] :param update: Whether or not to update and return the public key in-place. :return: The combined public key, or the modified public key if <code>update</code> is <code>True</code>. :rtype: PublicKey :raises ValueError: If the sum of the public keys was invalid.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def combine(self, public_keys, update: bool = False):  # noqa: FBT001, FBT002\n    \"\"\"\n    Add a number of public keys together.\n\n    :param public_keys: A sequence of public keys.\n    :type public_keys: List[PublicKey]\n    :param update: Whether or not to update and return the public key in-place.\n    :return: The combined public key, or the modified public key if `update` is `True`.\n    :rtype: PublicKey\n    :raises ValueError: If the sum of the public keys was invalid.\n    \"\"\"\n    new_key = ffi.new(\"secp256k1_pubkey *\")\n\n    combined = lib.secp256k1_ec_pubkey_combine(\n        self.context.ctx, new_key, [pk.public_key for pk in [self, *public_keys]], len(public_keys) + 1\n    )\n\n    if not combined:\n        msg = \"The sum of the public keys is invalid.\"\n        raise ValueError(msg)\n\n    if update:\n        self.public_key = new_key\n        return self\n\n    return PublicKey(new_key, self.context)\n</code></pre>"},{"location":"api/#coincurve.PublicKey.combine_keys","title":"<code>combine_keys(public_keys, context: Context = GLOBAL_CONTEXT)</code>  <code>classmethod</code>","text":"<p>Add a number of public keys together.</p> <p>:param public_keys: A sequence of public keys. :type public_keys: List[PublicKey] :param context: :return: The combined public key. :rtype: PublicKey :raises ValueError: If the sum of the public keys was invalid.</p> Source code in <code>coincurve/keys.py</code> <pre><code>@classmethod\ndef combine_keys(cls, public_keys, context: Context = GLOBAL_CONTEXT):\n    \"\"\"\n    Add a number of public keys together.\n\n    :param public_keys: A sequence of public keys.\n    :type public_keys: List[PublicKey]\n    :param context:\n    :return: The combined public key.\n    :rtype: PublicKey\n    :raises ValueError: If the sum of the public keys was invalid.\n    \"\"\"\n    public_key = ffi.new(\"secp256k1_pubkey *\")\n\n    combined = lib.secp256k1_ec_pubkey_combine(\n        context.ctx, public_key, [pk.public_key for pk in public_keys], len(public_keys)\n    )\n\n    if not combined:\n        msg = \"The sum of the public keys is invalid.\"\n        raise ValueError(msg)\n\n    return PublicKey(public_key, context)\n</code></pre>"},{"location":"api/#coincurve.PublicKey.format","title":"<code>format(compressed: bool = True) -&gt; bytes</code>","text":"<p>Format the public key.</p> <p>:param compressed: Whether or to use the compressed format. :return: The 33 byte formatted public key, or the 65 byte formatted public key if <code>compressed</code> is <code>False</code>.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def format(self, compressed: bool = True) -&gt; bytes:  # noqa: FBT001, FBT002\n    \"\"\"\n    Format the public key.\n\n    :param compressed: Whether or to use the compressed format.\n    :return: The 33 byte formatted public key, or the 65 byte formatted public key if `compressed` is `False`.\n    \"\"\"\n    length = 33 if compressed else 65\n    serialized = ffi.new(\"unsigned char [%d]\" % length)  # noqa: UP031\n    output_len = ffi.new(\"size_t *\", length)\n\n    lib.secp256k1_ec_pubkey_serialize(\n        self.context.ctx, serialized, output_len, self.public_key, EC_COMPRESSED if compressed else EC_UNCOMPRESSED\n    )\n\n    return bytes(ffi.buffer(serialized, length))\n</code></pre>"},{"location":"api/#coincurve.PublicKey.from_point","title":"<code>from_point(x: int, y: int, context: Context = GLOBAL_CONTEXT)</code>  <code>classmethod</code>","text":"<p>Derive a public key from a coordinate point in the form <code>(x, y)</code>.</p> <p>:param x: :param y: :param context: :return: The public key. :rtype: PublicKey</p> Source code in <code>coincurve/keys.py</code> <pre><code>@classmethod\ndef from_point(cls, x: int, y: int, context: Context = GLOBAL_CONTEXT):\n    \"\"\"\n    Derive a public key from a coordinate point in the form `(x, y)`.\n\n    :param x:\n    :param y:\n    :param context:\n    :return: The public key.\n    :rtype: PublicKey\n    \"\"\"\n    return PublicKey(b\"\\x04\" + int_to_bytes_padded(x) + int_to_bytes_padded(y), context)\n</code></pre>"},{"location":"api/#coincurve.PublicKey.from_secret","title":"<code>from_secret(secret: bytes, context: Context = GLOBAL_CONTEXT)</code>  <code>classmethod</code>","text":"<p>Derive a public key from a private key secret.</p> <p>:param secret: The private key secret. :param context: :return: The public key. :rtype: PublicKey</p> Source code in <code>coincurve/keys.py</code> <pre><code>@classmethod\ndef from_secret(cls, secret: bytes, context: Context = GLOBAL_CONTEXT):\n    \"\"\"\n    Derive a public key from a private key secret.\n\n    :param secret: The private key secret.\n    :param context:\n    :return: The public key.\n    :rtype: PublicKey\n    \"\"\"\n    public_key = ffi.new(\"secp256k1_pubkey *\")\n\n    created = lib.secp256k1_ec_pubkey_create(context.ctx, public_key, validate_secret(secret))\n\n    if not created:  # no cov\n        msg = (\n            \"Somehow an invalid secret was used. Please \"\n            \"submit this as an issue here: \"\n            \"https://github.com/ofek/coincurve/issues/new\"\n        )\n        raise ValueError(msg)\n\n    return PublicKey(public_key, context)\n</code></pre>"},{"location":"api/#coincurve.PublicKey.from_signature_and_message","title":"<code>from_signature_and_message(signature: bytes, message: bytes, hasher: Hasher = sha256, context: Context = GLOBAL_CONTEXT)</code>  <code>classmethod</code>","text":"<p>Recover an ECDSA public key from a recoverable signature.</p> <p>:param signature: The recoverable ECDSA signature. :param message: The message that was supposedly signed. :param hasher: The hash function to use, which must return 32 bytes. By default,                the <code>sha256</code> algorithm is used. If <code>None</code>, no hashing occurs. :param context: :return: The public key that signed the message. :rtype: PublicKey :raises ValueError: If the message hash was not 32 bytes long or recovery of the ECDSA public key failed.</p> Source code in <code>coincurve/keys.py</code> <pre><code>@classmethod\ndef from_signature_and_message(\n    cls, signature: bytes, message: bytes, hasher: Hasher = sha256, context: Context = GLOBAL_CONTEXT\n):\n    \"\"\"\n    Recover an ECDSA public key from a recoverable signature.\n\n    :param signature: The recoverable ECDSA signature.\n    :param message: The message that was supposedly signed.\n    :param hasher: The hash function to use, which must return 32 bytes. By default,\n                   the `sha256` algorithm is used. If `None`, no hashing occurs.\n    :param context:\n    :return: The public key that signed the message.\n    :rtype: PublicKey\n    :raises ValueError: If the message hash was not 32 bytes long or recovery of the ECDSA public key failed.\n    \"\"\"\n    return PublicKey(\n        recover(message, deserialize_recoverable(signature, context=context), hasher=hasher, context=context)\n    )\n</code></pre>"},{"location":"api/#coincurve.PublicKey.from_valid_secret","title":"<code>from_valid_secret(secret: bytes, context: Context = GLOBAL_CONTEXT)</code>  <code>classmethod</code>","text":"Source code in <code>coincurve/keys.py</code> <pre><code>@classmethod\ndef from_valid_secret(cls, secret: bytes, context: Context = GLOBAL_CONTEXT):\n    public_key = ffi.new(\"secp256k1_pubkey *\")\n\n    created = lib.secp256k1_ec_pubkey_create(context.ctx, public_key, secret)\n\n    if not created:\n        msg = \"Invalid secret.\"\n        raise ValueError(msg)\n\n    return PublicKey(public_key, context)\n</code></pre>"},{"location":"api/#coincurve.PublicKey.multiply","title":"<code>multiply(scalar: bytes, update: bool = False)</code>","text":"<p>Multiply the public key by a scalar.</p> <p>:param scalar: The scalar with which to multiply. :param update: Whether or not to update and return the public key in-place. :return: The new public key, or the modified public key if <code>update</code> is <code>True</code>. :rtype: PublicKey</p> Source code in <code>coincurve/keys.py</code> <pre><code>def multiply(self, scalar: bytes, update: bool = False):  # noqa: FBT001, FBT002\n    \"\"\"\n    Multiply the public key by a scalar.\n\n    :param scalar: The scalar with which to multiply.\n    :param update: Whether or not to update and return the public key in-place.\n    :return: The new public key, or the modified public key if `update` is `True`.\n    :rtype: PublicKey\n    \"\"\"\n    scalar = validate_secret(scalar)\n\n    new_key = ffi.new(\"secp256k1_pubkey *\", self.public_key[0])\n\n    lib.secp256k1_ec_pubkey_tweak_mul(self.context.ctx, new_key, scalar)\n\n    if update:\n        self.public_key = new_key\n        return self\n\n    return PublicKey(new_key, self.context)\n</code></pre>"},{"location":"api/#coincurve.PublicKey.point","title":"<code>point() -&gt; tuple[int, int]</code>","text":"<p>:return: The public key as a coordinate point.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def point(self) -&gt; tuple[int, int]:\n    \"\"\"\n    :return: The public key as a coordinate point.\n    \"\"\"\n    public_key = self.format(compressed=False)\n    return bytes_to_int(public_key[1:33]), bytes_to_int(public_key[33:])\n</code></pre>"},{"location":"api/#coincurve.PublicKey.verify","title":"<code>verify(signature: bytes, message: bytes, hasher: Hasher = sha256) -&gt; bool</code>","text":"<p>:param signature: The ECDSA signature. :param message: The message that was supposedly signed. :param hasher: The hash function to use, which must return 32 bytes. By default,                the <code>sha256</code> algorithm is used. If <code>None</code>, no hashing occurs. :return: A boolean indicating whether or not the signature is correct. :raises ValueError: If the message hash was not 32 bytes long or the DER-encoded signature could not be parsed.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def verify(self, signature: bytes, message: bytes, hasher: Hasher = sha256) -&gt; bool:\n    \"\"\"\n    :param signature: The ECDSA signature.\n    :param message: The message that was supposedly signed.\n    :param hasher: The hash function to use, which must return 32 bytes. By default,\n                   the `sha256` algorithm is used. If `None`, no hashing occurs.\n    :return: A boolean indicating whether or not the signature is correct.\n    :raises ValueError: If the message hash was not 32 bytes long or the DER-encoded signature could not be parsed.\n    \"\"\"\n    msg_hash = hasher(message) if hasher is not None else message\n    if len(msg_hash) != 32:  # noqa: PLR2004\n        msg = \"Message hash must be 32 bytes long.\"\n        raise ValueError(msg)\n\n    verified = lib.secp256k1_ecdsa_verify(self.context.ctx, der_to_cdata(signature), msg_hash, self.public_key)\n\n    # A performance hack to avoid global bool() lookup.\n    return not not verified  # noqa: SIM208\n</code></pre>"},{"location":"api/#coincurve.PublicKeyXOnly","title":"<code>PublicKeyXOnly</code>","text":"Source code in <code>coincurve/keys.py</code> <pre><code>class PublicKeyXOnly:\n    def __init__(self, data, parity: bool = False, context: Context = GLOBAL_CONTEXT):  # noqa: FBT001, FBT002\n        \"\"\"A BIP340 `x-only` public key.\n\n        :param data: The formatted public key.\n        :type data: bytes\n        :param parity: Whether the encoded point is the negation of the public key.\n        :param context:\n        \"\"\"\n        if not isinstance(data, bytes):\n            self.public_key = data\n        else:\n            public_key = ffi.new(\"secp256k1_xonly_pubkey *\")\n            parsed = lib.secp256k1_xonly_pubkey_parse(context.ctx, public_key, data)\n            if not parsed:\n                msg = \"The public key could not be parsed or is invalid.\"\n                raise ValueError(msg)\n\n            self.public_key = public_key\n\n        self.parity = parity\n        self.context = context\n\n    @classmethod\n    def from_secret(cls, secret: bytes, context: Context = GLOBAL_CONTEXT):\n        \"\"\"Derive an x-only public key from a private key secret.\n\n        :param secret: The private key secret.\n        :param context:\n        :return: The x-only public key.\n        \"\"\"\n        keypair = ffi.new(\"secp256k1_keypair *\")\n        res = lib.secp256k1_keypair_create(context.ctx, keypair, validate_secret(secret))\n        if not res:\n            msg = \"Secret was invalid\"\n            raise ValueError(msg)\n\n        xonly_pubkey = ffi.new(\"secp256k1_xonly_pubkey *\")\n        pk_parity = ffi.new(\"int *\")\n        res = lib.secp256k1_keypair_xonly_pub(context.ctx, xonly_pubkey, pk_parity, keypair)\n\n        return cls(xonly_pubkey, parity=not not pk_parity[0], context=context)  # noqa: SIM208\n\n    @classmethod\n    def from_valid_secret(cls, secret: bytes, context: Context = GLOBAL_CONTEXT):\n        keypair = ffi.new(\"secp256k1_keypair *\")\n        res = lib.secp256k1_keypair_create(context.ctx, keypair, secret)\n        if not res:\n            msg = \"Secret was invalid\"\n            raise ValueError(msg)\n\n        xonly_pubkey = ffi.new(\"secp256k1_xonly_pubkey *\")\n        pk_parity = ffi.new(\"int *\")\n        res = lib.secp256k1_keypair_xonly_pub(context.ctx, xonly_pubkey, pk_parity, keypair)\n\n        return cls(xonly_pubkey, parity=not not pk_parity[0], context=context)  # noqa: SIM208\n\n    def format(self) -&gt; bytes:\n        \"\"\"Serialize the public key.\n\n        :return: The public key serialized as 32 bytes.\n        \"\"\"\n        output32 = ffi.new(\"unsigned char [32]\")\n\n        res = lib.secp256k1_xonly_pubkey_serialize(self.context.ctx, output32, self.public_key)\n        if not res:\n            msg = \"Public key in self.public_key must be valid\"\n            raise ValueError(msg)\n\n        return bytes(ffi.buffer(output32, 32))\n\n    def verify(self, signature: bytes, message: bytes) -&gt; bool:\n        \"\"\"Verify a Schnorr signature over a given message.\n\n        :param signature: The 64-byte Schnorr signature to verify.\n        :param message: The message to be verified.\n        :return: A boolean indicating whether or not the signature is correct.\n        \"\"\"\n        if len(signature) != 64:  # noqa: PLR2004\n            msg = \"Signature must be 64 bytes long.\"\n            raise ValueError(msg)\n\n        return not not lib.secp256k1_schnorrsig_verify(  # noqa: SIM208\n            self.context.ctx, signature, message, len(message), self.public_key\n        )\n\n    def tweak_add(self, scalar: bytes):\n        \"\"\"Add a scalar to the public key.\n\n        :param scalar: The scalar with which to add.\n        :return: The modified public key.\n        :rtype: PublicKeyXOnly\n        :raises ValueError: If the tweak was out of range or the resulting public key was invalid.\n        \"\"\"\n        scalar = pad_scalar(scalar)\n\n        out_pubkey = ffi.new(\"secp256k1_pubkey *\")\n        res = lib.secp256k1_xonly_pubkey_tweak_add(self.context.ctx, out_pubkey, self.public_key, scalar)\n        if not res:\n            msg = \"The tweak was out of range, or the resulting public key would be invalid\"\n            raise ValueError(msg)\n\n        pk_parity = ffi.new(\"int *\")\n        lib.secp256k1_xonly_pubkey_from_pubkey(self.context.ctx, self.public_key, pk_parity, out_pubkey)\n        self.parity = not not pk_parity[0]  # noqa: SIM208\n\n    def __eq__(self, other) -&gt; bool:\n        res = lib.secp256k1_xonly_pubkey_cmp(self.context.ctx, self.public_key, other.public_key)\n        return res == 0\n\n    def __hash__(self) -&gt; int:\n        return hash(self.format())\n</code></pre>"},{"location":"api/#coincurve.PublicKeyXOnly.context","title":"<code>context = context</code>  <code>instance-attribute</code>","text":""},{"location":"api/#coincurve.PublicKeyXOnly.parity","title":"<code>parity = parity</code>  <code>instance-attribute</code>","text":""},{"location":"api/#coincurve.PublicKeyXOnly.public_key","title":"<code>public_key = data</code>  <code>instance-attribute</code>","text":""},{"location":"api/#coincurve.PublicKeyXOnly.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>coincurve/keys.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    res = lib.secp256k1_xonly_pubkey_cmp(self.context.ctx, self.public_key, other.public_key)\n    return res == 0\n</code></pre>"},{"location":"api/#coincurve.PublicKeyXOnly.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"Source code in <code>coincurve/keys.py</code> <pre><code>def __hash__(self) -&gt; int:\n    return hash(self.format())\n</code></pre>"},{"location":"api/#coincurve.PublicKeyXOnly.__init__","title":"<code>__init__(data, parity: bool = False, context: Context = GLOBAL_CONTEXT)</code>","text":"<p>A BIP340 <code>x-only</code> public key.</p> <p>:param data: The formatted public key. :type data: bytes :param parity: Whether the encoded point is the negation of the public key. :param context:</p> Source code in <code>coincurve/keys.py</code> <pre><code>def __init__(self, data, parity: bool = False, context: Context = GLOBAL_CONTEXT):  # noqa: FBT001, FBT002\n    \"\"\"A BIP340 `x-only` public key.\n\n    :param data: The formatted public key.\n    :type data: bytes\n    :param parity: Whether the encoded point is the negation of the public key.\n    :param context:\n    \"\"\"\n    if not isinstance(data, bytes):\n        self.public_key = data\n    else:\n        public_key = ffi.new(\"secp256k1_xonly_pubkey *\")\n        parsed = lib.secp256k1_xonly_pubkey_parse(context.ctx, public_key, data)\n        if not parsed:\n            msg = \"The public key could not be parsed or is invalid.\"\n            raise ValueError(msg)\n\n        self.public_key = public_key\n\n    self.parity = parity\n    self.context = context\n</code></pre>"},{"location":"api/#coincurve.PublicKeyXOnly.format","title":"<code>format() -&gt; bytes</code>","text":"<p>Serialize the public key.</p> <p>:return: The public key serialized as 32 bytes.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def format(self) -&gt; bytes:\n    \"\"\"Serialize the public key.\n\n    :return: The public key serialized as 32 bytes.\n    \"\"\"\n    output32 = ffi.new(\"unsigned char [32]\")\n\n    res = lib.secp256k1_xonly_pubkey_serialize(self.context.ctx, output32, self.public_key)\n    if not res:\n        msg = \"Public key in self.public_key must be valid\"\n        raise ValueError(msg)\n\n    return bytes(ffi.buffer(output32, 32))\n</code></pre>"},{"location":"api/#coincurve.PublicKeyXOnly.from_secret","title":"<code>from_secret(secret: bytes, context: Context = GLOBAL_CONTEXT)</code>  <code>classmethod</code>","text":"<p>Derive an x-only public key from a private key secret.</p> <p>:param secret: The private key secret. :param context: :return: The x-only public key.</p> Source code in <code>coincurve/keys.py</code> <pre><code>@classmethod\ndef from_secret(cls, secret: bytes, context: Context = GLOBAL_CONTEXT):\n    \"\"\"Derive an x-only public key from a private key secret.\n\n    :param secret: The private key secret.\n    :param context:\n    :return: The x-only public key.\n    \"\"\"\n    keypair = ffi.new(\"secp256k1_keypair *\")\n    res = lib.secp256k1_keypair_create(context.ctx, keypair, validate_secret(secret))\n    if not res:\n        msg = \"Secret was invalid\"\n        raise ValueError(msg)\n\n    xonly_pubkey = ffi.new(\"secp256k1_xonly_pubkey *\")\n    pk_parity = ffi.new(\"int *\")\n    res = lib.secp256k1_keypair_xonly_pub(context.ctx, xonly_pubkey, pk_parity, keypair)\n\n    return cls(xonly_pubkey, parity=not not pk_parity[0], context=context)  # noqa: SIM208\n</code></pre>"},{"location":"api/#coincurve.PublicKeyXOnly.from_valid_secret","title":"<code>from_valid_secret(secret: bytes, context: Context = GLOBAL_CONTEXT)</code>  <code>classmethod</code>","text":"Source code in <code>coincurve/keys.py</code> <pre><code>@classmethod\ndef from_valid_secret(cls, secret: bytes, context: Context = GLOBAL_CONTEXT):\n    keypair = ffi.new(\"secp256k1_keypair *\")\n    res = lib.secp256k1_keypair_create(context.ctx, keypair, secret)\n    if not res:\n        msg = \"Secret was invalid\"\n        raise ValueError(msg)\n\n    xonly_pubkey = ffi.new(\"secp256k1_xonly_pubkey *\")\n    pk_parity = ffi.new(\"int *\")\n    res = lib.secp256k1_keypair_xonly_pub(context.ctx, xonly_pubkey, pk_parity, keypair)\n\n    return cls(xonly_pubkey, parity=not not pk_parity[0], context=context)  # noqa: SIM208\n</code></pre>"},{"location":"api/#coincurve.PublicKeyXOnly.tweak_add","title":"<code>tweak_add(scalar: bytes)</code>","text":"<p>Add a scalar to the public key.</p> <p>:param scalar: The scalar with which to add. :return: The modified public key. :rtype: PublicKeyXOnly :raises ValueError: If the tweak was out of range or the resulting public key was invalid.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def tweak_add(self, scalar: bytes):\n    \"\"\"Add a scalar to the public key.\n\n    :param scalar: The scalar with which to add.\n    :return: The modified public key.\n    :rtype: PublicKeyXOnly\n    :raises ValueError: If the tweak was out of range or the resulting public key was invalid.\n    \"\"\"\n    scalar = pad_scalar(scalar)\n\n    out_pubkey = ffi.new(\"secp256k1_pubkey *\")\n    res = lib.secp256k1_xonly_pubkey_tweak_add(self.context.ctx, out_pubkey, self.public_key, scalar)\n    if not res:\n        msg = \"The tweak was out of range, or the resulting public key would be invalid\"\n        raise ValueError(msg)\n\n    pk_parity = ffi.new(\"int *\")\n    lib.secp256k1_xonly_pubkey_from_pubkey(self.context.ctx, self.public_key, pk_parity, out_pubkey)\n    self.parity = not not pk_parity[0]  # noqa: SIM208\n</code></pre>"},{"location":"api/#coincurve.PublicKeyXOnly.verify","title":"<code>verify(signature: bytes, message: bytes) -&gt; bool</code>","text":"<p>Verify a Schnorr signature over a given message.</p> <p>:param signature: The 64-byte Schnorr signature to verify. :param message: The message to be verified. :return: A boolean indicating whether or not the signature is correct.</p> Source code in <code>coincurve/keys.py</code> <pre><code>def verify(self, signature: bytes, message: bytes) -&gt; bool:\n    \"\"\"Verify a Schnorr signature over a given message.\n\n    :param signature: The 64-byte Schnorr signature to verify.\n    :param message: The message to be verified.\n    :return: A boolean indicating whether or not the signature is correct.\n    \"\"\"\n    if len(signature) != 64:  # noqa: PLR2004\n        msg = \"Signature must be 64 bytes long.\"\n        raise ValueError(msg)\n\n    return not not lib.secp256k1_schnorrsig_verify(  # noqa: SIM208\n        self.context.ctx, signature, message, len(message), self.public_key\n    )\n</code></pre>"},{"location":"history/","title":"History","text":"<p>Important changes are emphasized.</p>"},{"location":"history/#unreleased","title":"Unreleased","text":"<ul> <li>Breaking: Drop support for Python 3.8</li> <li>Add support for Python 3.13</li> <li>Remove <code>cffi</code> as a runtime dependency</li> <li>Add <code>COINCURVE_VENDOR_CFFI</code> environment variable to control vendoring of the <code>_cffi_backend</code> module</li> <li>Minor performance improvement by removing use of formatted string constants</li> <li>Upgrade libsecp256k1 to version 0.6.0</li> </ul>"},{"location":"history/#2000","title":"20.0.0","text":"<ul> <li>Breaking: CMake is now a build dependency; this is only a breaking change for redistributors as building with standard Python packaging tools will automatically use the CMake that is available on PyPI</li> <li>Breaking: Stop building wheels for Windows 32-bit</li> <li>Build wheels for Windows ARM64</li> <li>Upgrade libsecp256k1 to version 0.5.0</li> </ul>"},{"location":"history/#1901","title":"19.0.1","text":"<ul> <li>Fix regression in Windows wheels</li> </ul>"},{"location":"history/#1900","title":"19.0.0","text":"<ul> <li>Breaking: Drop support for Python 3.7</li> <li>Add support for Python 3.12</li> <li>Upgrade libsecp256k1 to version 0.4.1</li> </ul>"},{"location":"history/#1800","title":"18.0.0","text":"<ul> <li>Support Schnorr signatures</li> <li>Add support for Python 3.11</li> <li>Upgrade libsecp256k1 to the latest available version</li> </ul>"},{"location":"history/#1700","title":"17.0.0","text":"<ul> <li>Breaking: Drop support for Python 3.6</li> <li>Fix wheels for Apple M1</li> <li>Upgrade libsecp256k1 to the latest available version</li> </ul>"},{"location":"history/#1600","title":"16.0.0","text":"<ul> <li>Wheels for Apple Silicon and musl linux (Alpine)</li> <li>No wheels for PyPy until the build system is fixed</li> </ul>"},{"location":"history/#1501","title":"15.0.1","text":"<ul> <li>Fix the <code>combine</code> method of <code>PublicKey</code></li> </ul>"},{"location":"history/#1500","title":"15.0.0","text":"<ul> <li>Breaking: Drop support for Python 2</li> <li>Breaking: Binary wheels for CPython require version 19.3 or later of <code>pip</code> to install</li> <li>Build AArch64 binary wheels for Linux</li> <li>Build binary wheels for PyPy3.6 7.3.3 &amp; PyPy3.7 7.3.3 on Linux</li> <li>Upgrade libsecp256k1 to the latest available version</li> <li>Upgrade libgmp to the latest available version</li> <li>Introduce <code>COINCURVE_UPSTREAM_REF</code> environment variable to select an alternative libsecp256k1 version when building from source</li> <li>Support PEP 561 type hints</li> <li>Added support for supplying a custom nonce to <code>PrivateKey.sign_recoverable</code></li> </ul>"},{"location":"history/#1400","title":"14.0.0","text":"<p>IMPORTANT: This will be the final release that supports Python 2.</p> <ul> <li>New: Binary wheels for Python 3.9</li> <li>Breaking: Drop support for Python 3.5</li> <li>Fetch libsecp256k1 source if the system installation lacks ECDH support</li> <li>Fix innocuous <code>setuptools</code> warning when building from source</li> <li>Switch CI/CD to GitHub Actions</li> </ul>"},{"location":"history/#1300","title":"13.0.0","text":"<ul> <li>New: Binary wheels for Python 3.8</li> <li>Support building on OpenBSD</li> <li>Improve handling of PEM private key deserialization</li> <li>Improve ECDH documentation</li> <li>Improvements from libsecp256k1 master</li> </ul>"},{"location":"history/#1200","title":"12.0.0","text":"<ul> <li>New: Binary wheels on Linux for PyPy3.6 v7.1.1-beta</li> <li>New: Binary wheels on macOS for Python 3.8.0-alpha.3</li> <li>New: Binary wheels on Linux are now also built with the new manylinux2010 spec for 64-bit platforms</li> <li>Improvements from libsecp256k1 master</li> </ul>"},{"location":"history/#1100","title":"11.0.0","text":"<ul> <li>Fix some linking scenarios by placing bundled libsecp256k1 dir first in path</li> <li>Allow override of system libsecp256k1 with environment variable</li> <li>Add benchmarks</li> <li>Use Codecov to track coverage</li> <li>Use black for code formatting</li> </ul>"},{"location":"history/#1000","title":"10.0.0","text":"<ul> <li>Support tox for testing</li> <li>Compatibility with latest libsecp256k1 ECDH API</li> <li>Make libgmp optional when building from source</li> </ul>"},{"location":"history/#900","title":"9.0.0","text":"<ul> <li>Fixed wheels for macOS</li> <li>Breaking: Drop support for 32-bit macOS</li> </ul>"},{"location":"history/#802","title":"8.0.2","text":"<ul> <li>No longer package tests</li> </ul>"},{"location":"history/#800","title":"8.0.0","text":"<ul> <li>New: Binary wheels for Python 3.7</li> <li>Changed: Binary wheels on macOS for Python 3.5 now use Homebrew   Python for compilation due to new security requirements</li> <li>Make build system support new GitHub &amp; PyPI security requirements</li> <li>Improvements from libsecp256k1 master</li> </ul>"},{"location":"history/#710","title":"7.1.0","text":"<ul> <li>Pin version of libsecp256k1</li> <li>Improve docs</li> </ul>"},{"location":"history/#700","title":"7.0.0","text":"<ul> <li>Improvements from libsecp256k1 master</li> <li>Fix build script</li> </ul>"},{"location":"history/#600","title":"6.0.0","text":"<ul> <li>Resolved #6. You can choose to use this or remain on <code>5.2.0</code>. This will only be a temporary change, see 3e93480.</li> </ul>"},{"location":"history/#520","title":"5.2.0","text":"<ul> <li>Added support for supplying a custom nonce to <code>PrivateKey.sign</code></li> </ul>"},{"location":"history/#510","title":"5.1.0","text":"<ul> <li>Added <code>PublicKey.combine_keys</code> class method</li> <li>Improvements to documentation</li> </ul>"},{"location":"history/#501","title":"5.0.1","text":"<ul> <li>Fixed an issue where secret validation would occasionally erroneously error   on user-provided secrets (secrets not generated by Coincurve itself) if there   were not exactly 256 bits of entropy. See #5.</li> </ul>"},{"location":"history/#500","title":"5.0.0","text":"<ul> <li>Breaking: Coincurve is now dual-licensed under the terms of <code>MIT</code> and <code>Apache-2.0</code></li> <li>Performance improvements from libsecp256k1 master</li> <li>Improvements to documentation.</li> </ul>"},{"location":"history/#451","title":"4.5.1","text":"<ul> <li>First public stable release</li> </ul>"},{"location":"install/","title":"Installation","text":"<p><code>coincurve</code> is available on PyPI and can be installed with pip:</p> <pre><code>pip install coincurve\n</code></pre>"},{"location":"install/#wheel","title":"Wheel","text":"<p>Binary wheels are available for most platforms and require at least version <code>19.3</code> of pip to install.</p> macOS Windows Linux (glibc) Linux (musl) CPython 3.9 <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> CPython 3.10 <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> CPython 3.11 <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> CPython 3.12 <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> CPython 3.13 <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>ARM64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul> <ul><li>x86_64</li><li>i686</li><li>AArch64</li></ul>"},{"location":"install/#source","title":"Source","text":"<p>If you are on a platform without support for pre-compiled wheels, you will need certain system packages in order to build from source.</p> <p>A few environment variables influence the build:</p> <ul> <li><code>COINCURVE_UPSTREAM_REF</code> - This is the Git reference of libsecp256k1 to use rather than the (frequently updated) default.</li> <li><code>COINCURVE_IGNORE_SYSTEM_LIB</code> - The presence of this will force fetching of libsecp256k1 even if it's already detected at the system level.</li> <li><code>COINCURVE_VENDOR_CFFI</code> - Setting this to anything other than <code>1</code> (the default) prevents vendoring of the <code>_cffi_backend</code> module. Re-distributors should make sure to require <code>cffi</code> as a runtime dependency when disabling this.</li> </ul> <p>Tip</p> <p>To avoid installing the binary wheels on compatible distributions, use the <code>--no-binary</code> option.</p> <pre><code>pip install coincurve --no-binary coincurve\n</code></pre>"},{"location":"install/#alpine","title":"Alpine","text":"<pre><code>sudo apk add autoconf automake build-base libffi-dev libtool pkgconfig python3-dev\n</code></pre>"},{"location":"install/#debianubuntu","title":"Debian/Ubuntu","text":"<pre><code>sudo apt-get install -y autoconf automake build-essential libffi-dev libtool pkg-config python3-dev\n</code></pre>"},{"location":"install/#rhelcentos","title":"RHEL/CentOS","text":"<pre><code>sudo yum install -y autoconf automake gcc gcc-c++ libffi-devel libtool make pkgconfig python3-devel\n</code></pre>"},{"location":"install/#macos","title":"macOS","text":"<pre><code>xcode-select --install\nbrew install autoconf automake libffi libtool pkg-config python\n</code></pre>"},{"location":"users/","title":"Users","text":""},{"location":"users/#organizations","title":"Organizations","text":"Name Projects Anyl <ul><li> anyledger-backend </li></ul> ARK <ul><li> python-crypto </li></ul> Augur <ul><li> augur-core </li></ul> Blockcerts <ul><li> cert-issuer </li></ul> ECIES <ul><li> py </li></ul> Elements <ul><li> lightning </li></ul> Ethereum <ul><li> alexandria </li><li> ddht </li><li> eth-keys </li><li> eth-tester </li><li> py-evm </li><li> pydevp2p </li><li> trinity </li></ul> Gnosis <ul><li> gnosis-py </li></ul> Golem Network <ul><li> concent </li><li> golem </li><li> golem-messages </li></ul> ICON Foundation <ul><li> goloop </li><li> icon-sdk-python </li><li> icon-service </li><li> loopchain </li><li> t-bears </li></ul> LBRY <ul><li> lbry-android-sdk </li><li> lbry-sdk </li></ul> libp2p <ul><li> py-libp2p </li></ul> Microsoft <ul><li> CCF </li></ul> NuCypher <ul><li> nucypher </li><li> nucypher-monitor </li></ul> Quantstamp <ul><li> qsp-protocol-node </li></ul> QuarkChain <ul><li> pyquarkchain </li></ul> Raiden Network <ul><li> demo-train </li><li> light-client </li><li> microraiden </li><li> raiden </li><li> raiden-contracts </li><li> raiden-service-bundle </li><li> raiden-services </li><li> raiden-wizard </li><li> raidex </li></ul> SKALE Network <ul><li> libBLS </li><li> sgx.py </li></ul>"},{"location":"users/#projects","title":"Projects","text":"<ul> <li>bit</li> <li>btcrecover</li> <li>crankycoin</li> <li>ForkDelta</li> <li>Heimdall</li> <li>HoneyBadgerBFT</li> <li>JoinMarket</li> <li>minichain</li> <li>Nekoyume</li> <li>NuCypher</li> <li>python-idex</li> <li>Rotki</li> <li>Vyper</li> <li>ZeroNet</li> </ul>"}]}